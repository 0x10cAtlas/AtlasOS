; AtlasOS
; A multiprocess capable DCPU OS by Plusmid and Chessmaster42
; AtlasOS version 0.5.6
; Atlas-Shell version 0.4.0

:kernel_boot
; clear screen (for emulator)
JSR clear

; low level routines
; runs best in DCPU-16 Studio (http://badsector.github.com/dcpustud/)

; Display the logo
SET A, text_logo1
JSR text_out

; Bootmessage
SET A, text_start
JSR text_out

; Reserve kernel-memory
SET X, 0
:kernel_mem
IFG X, kernel_end
    SET PC, kernel_mem_end
SET A, X
JSR page_reserve
ADD X, 1024
SET PC, kernel_mem
:kernel_mem_end

; Reserve video-memory
SET A, 0x8000
JSR page_reserve

; Reserve stack-memory
SET A, 0xFFFF
JSR page_reserve

; Reserve the API space
SET A, 0x1000
JSR page_reserve

;Reserve application memory
SET A, apps
:apps_mem
IFG A, apps_end
    SET PC, apps_mem_end
SET X, A
JSR page_reserve
SET A, X
ADD A, 1024
SET PC, apps_mem
:apps_mem_end

;Reserve virtual filesystem memory
SET A, files
:files_mem
IFG A, files_end
    SET PC, files_mem_end
SET X, A
JSR page_reserve
SET A, X
ADD A, 1024
SET PC, files_mem
:files_mem_end

SET X, 0

; Copy the API.
SET B, 0x1000
SET A, api_start
SET C, api_end
SUB C, A
JSR mem_copy

; OS ready message
SET A, text_start_ok
JSR text_out

; Clear out a few things
SET [keyboard_buffers_exclusive], 0
SET [keyboard_oldvalue], 0
JSR keyboard_unregister_all

; The kernel constantly polls the keyboard.
:kernel_loop

	; Call the keyboard driver
	JSR driver_keyboard

	; Check if the kernel is the only running process, if so start the shell
	JSR kernel_watchdog_checkalone

    JSR proc_suspend
    SET PC, kernel_loop

:kernel_watchdog_checkalone
	SET PUSH, C
	SET PUSH, B
	SET PUSH, A

	SET C, kernel_watchdog_proc_list_buffer
	SET A, kernel_watchdog_helper
	JSR proc_callback_list
	SET C, kernel_watchdog_proc_list_buffer
	ADD C, 1
	IFE [C], 0
		JSR kernel_watchdog_loadshell

	; Clear the proc buffer
	SET C, kernel_watchdog_proc_list_buffer
	SET [C], 0
	ADD C, 1
	SET [C], 0

	SET A, POP
	SET B, POP
	SET C, POP
	SET PC, POP
:kernel_watchdog_helper
	IFE C, kernel_watchdog_proc_list_buffer_end
		SET PC, POP
	SET [C], A
	ADD C, 1
	SET PC, POP
:kernel_watchdog_loadshell
	; This is a workaround so the shell doesn't freak out
	; when there is no data in the keyboard buffer
	SET [keyboard_oldvalue], 0xFFFF
	; Now start the shell
	SET A, AtlasShell
	SET B, AtlasShell_end
	SUB B, AtlasShell
	JSR proc_load
	SET PC, POP

; START OF THE KEYBOARD DRIVER
:driver_keyboard
    SET PUSH, A
    SET PUSH, B
	SET PUSH, C

	SET C, 0x9000
	SET B, 0x0000
:driver_keyboard_ringbuffloop
	; Find last non-zero value in the ring buffer (and reset the buffer to 0's)
	IFN [C], 0
		SET B, [C]
	; filter non-ascii - check if any of the upper 9 bits is set, if yes - reset to 0.
	SET A, B
	SHR A, 7
	IFN A, 0
		SET B, 0
	SET [C], 0
	ADD C, 1
	IFN C, 0x9010
		SET PC, driver_keyboard_ringbuffloop

	SET [C], B

	; Skip the driver if the key value hasn't changed
	IFE [C], [keyboard_oldvalue]
		SET PC, driver_keyboard_end

    SET A, keyboard_buffers

	IFN [keyboard_buffers_exclusive], 0
		SET PC, driver_keyboard_exclusive

:driver_keyboard_loop
	; Check to see if we have a buffer registered at this spot
    IFN [A], 0
        JSR driver_keyboard_save_to_buffer
	; Increment to the next buffer as long as we aren't at the end
    ADD A, 1
    IFN A, keyboard_buffers_end
        SET PC, driver_keyboard_loop
:driver_keyboard_end
	SET [keyboard_oldvalue], [C]
	SET [C], 0
	SET C, POP
	SET B, POP
    SET A, POP
    SET PC, POP

:driver_keyboard_exclusive
	SET B, [keyboard_buffers_exclusive]
	SET [B], [C]
	SET PC, driver_keyboard_end

:driver_keyboard_save_to_buffer
	SET B, [A]
	SET [B], [C]
	SET PC, POP

; END OF THE KEYBOARD DRIVER

SET PC, stop

; prints a text to stdout
; A: start address of the text
:text_out
      SET PUSH, A
      SET PUSH, B
      SET PUSH, C
      SET PUSH, I

      SET B, [video_col]
      SET I, [video_cur]

:text_out_loop
      SET C, [A]
      IFE C, 0x0000
          SET PC, text_out_end
      IFE C, 0x00A0
          SET PC, text_out_nl
      AND C, 0x00FF
      BOR C, B
      SET [I], C
      ADD A, 1
      ADD I, 1
      IFE I, 0x8180
          SET PC, text_out_scroll
      SET PC, text_out_loop

:text_out_scroll
      SET [video_cur], I
      JSR scroll
      SET I, [video_cur]
      SET PC, text_out_loop

:text_out_nl
      SET [video_cur], I
      JSR newline
      SET I, [video_cur]
      ADD A, 1
      SET PC, text_out_loop

:text_out_end
      SET [video_cur], I
      SET I, POP
      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

; Linefeed
:newline
      SET PUSH, A
      SET PUSH, B

      SET A, 0x0020
      SET B, [video_cur]
     ; SUB B, 0x8000
      MOD B, A
      SUB A, B
      ADD [video_cur], A
      IFE [video_cur], 0x8180
          JSR scroll

      SET B, POP
      SET A, POP
      SET PC, POP

; Scrolls the screen one line
:scroll
      SET PUSH, X
      SET PUSH, Y

      SET X, 0x8000 ; Set X to the video memory
      SET Y, 0x8020 ; Set Y to the second line in the video memory

:scroll_loop1
      SET [X], [Y]
      SET [1+X], [1+Y]
      SET [2+X], [2+Y]
      SET [3+X], [3+Y]

      ADD X, 4
      ADD Y, 4

      IFN Y, 0x8180
		SET PC, scroll_loop1

:scroll_loop2
      SET [X], [video_clear]
      ADD X, 1
      IFE X, 0x8180
          SET PC, scroll_end
      SET PC, scroll_loop2

:scroll_end
      SUB [video_cur], 0x20
      SET Y, POP
      SET X, POP
      SET PC, POP

; Clears the screen and sets the cursor to the first line (working)
:clear
      SET PUSH, A
      SET PUSH, B

      SET A, [video_mem]
      SET B, [video_clear]

:clear_loop
      SET [A], B
      SET [1+A], B
      SET [2+A], B
      SET [3+A], B
      ADD A, 4

      IFN A, 0x8180
          SET PC, clear_loop

:clear_end
      SET [video_cur], [video_mem]
      SET B, POP
      SET A, POP
      SET PC, POP

:get_pos
      SET PUSH, B

      IFG A, 31
          SET PC, get_pos_clip
      IFG B, 15
          SET PC, get_pos_clip

      MUL B, 32
      ADD B, 0x8000
      ADD B, A

      SET A, B

:get_pos_skip
      SET B, POP
      SET PC, POP

:get_pos_clip
      SET A, 0x0000
      SET PC, get_pos_skip


:char_put
      SET PUSH, A

      JSR get_pos
      SET [A], C

      SET A, POP
      SET PC, POP


; Converts a Number into a Decimal String
; A: Number
; B: StrBuffer (length 5)
:int2dec
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	ADD B, 4

:int2dec_loop
	SET C, A
	MOD C, 10

	SET [B], C
	ADD [B], 0x0030

	DIV A, 10
	SUB B, 1
	IFE A, 0
		SET PC, int2dec_end
	SET PC, int2dec_loop

:int2dec_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Converts a Number into a Hexadecimal String
; A: Number
; B: StrBuffer (length 4)
:int2hex
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	ADD B, 3

:int2hex_loop
	SET C, A
	AND C, 0x000F ; does the same thing as MOD, but AND takes one cycle, MOD takes 3

	SET [B], C
	ADD [B], 0x0030 ; adding 30 gives us a value of 30 to 3F
	IFG [B], 0x0039 ; if it's 3A or more, add seven
		ADD [B], 0x0007 ; giving us 30 - 39, 41 - 46

	DIV A, 16
	SUB B, 1
	IFE A, 0
		SET PC, int2hex_end
	SET PC, int2hex_loop

:int2hex_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Takes a text buffer containing an integer and converts it to an integer
; A: Address of text buffer
:atoi
     SET PUSH, A
     SET PUSH, B
     SET C, 0

:atoi_loop
     IFE [A], 0
     SET PC, atoi_end

     ; Capture the first digit and subtract 48 so our ASCII code for the digit becomes the numeric value of the digit
     SET B, [A]
     SUB B, 48

     ; Add the value of the digit to the accumulator
     ADD C, B

     ; Increment our address and multiply the accumulator
     ADD A, 1
     IFE [A], 0
     SET PC, atoi_end
     MUL C, 10
     SET PC, atoi_loop

:atoi_end
     SET B, POP
     SET A, POP
     SET PC, POP

; mem_clear
; A: From Addr
; B: Length
:mem_clear
      SET PUSH, A
      SET PUSH, B

      ADD B, A

:mem_clear_loop
      SET [A], 0
      ADD A, 1
      IFN A, B
          SET PC, mem_clear_loop

      SET B, POP
      SET A, POP
      SET PC, POP

; A -> source
; B -> dest
; C -> length
:mem_copy
      SET PUSH, A
      SET PUSH, B
      SET PUSH, C

      ; Calulate the last address
      ADD C, A

:mem_copy_loop
      SET [B], [A]
      ADD A, 1
      ADD B, 1
      IFN A, C
          SET PC, mem_copy_loop

      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

; A: Mem addr of the page
:page_reserve
      SET PUSH, B

      SET B, A
      MOD B, 1024
      SUB A, B
      DIV A, 1024        ; Set the pagenum

      JSR page_remove    ; Remove all occurences of this page
      SET B, 0x0001      ; By the OS
      JSR page_combine   ; Combine A (the page num) and B (the proc id) to the page entry
      BOR A, 0x8000      ; Set the "reserved" flag
      JSR page_add

      SET B, POP
      SET PC, POP

; A: Removes all entries with the given page num
:page_remove
      SET PUSH, A
      SET PUSH, B

      AND A, 0x003F
      SHL A, 8
      SET PUSH, A

      SET B, page_table

:page_remove_loop
      SET A, [B]
      AND A, 0x3F00
      IFE A, PEEK
          SET [B], 0x0000     ; Remove entry
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_remove_loop

      SET A, POP              ; Remove a from stack
      SET B, POP              ; Restore registers
      SET A, POP
      SET PC, POP

; A -> page num
; B -> proc id
; A <- combined page entry
:page_combine
      SET PUSH, B

      AND A, 0x003F
      SHL A, 8
      AND B, 0x00FF
      BOR A, B

      SET B, POP
      SET PC, POP

; A -> combined page entry
; A <- page num
; B <- proc id
:page_decombine
      SET B, A

      SHR A, 8
      AND A, 0x003F
      AND B, 0x00FF

      SET PC, POP

; Find an empty entry in the page_table and store the page descriptor.
; A -> combined page entry
; A <- 1 of succeeded, 0 if failed
:page_add
      SET PUSH, B
      SET B, page_table

:page_add_loop
      IFE [B], 0
          SET PC, page_add_set

      ADD B, 1
      IFN B, page_table_end
          SET PC, page_add_loop

      SET A, 0

:page_add_end
      SET B, POP
      SET PC, POP

:page_add_set
      SET [B], A

      JSR page_decombine
      JSR page_set_map

      SET A, 1
      SET PC, page_add_end

; Finds the first free page of memory by inspecting the bits of the page_map.
; A <- first free page number.
:page_find_free

      ;SET PC, page_find_free

      SET PUSH, B

      ; 0xFFFF means given 16kB is fully occupied.
      SET A, page_map
      SET B, 0
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found

      ; Nothing found, exiting! (later: Swap)
      SET A, 0

:page_find_free_end
      SET B, POP
      SET PC, POP

; Find free page within this 16kB block by looking for a bit set to 0.
:page_find_free_found
      SET PUSH, [A]
	  ; B is the id of the page_map word - each word covers 16 pages.
      MUL B, 16
	  ; A will hold the final number.
      SET A, B

:page_find_free_found_loop
      SHR PEEK, 1
      IFN O, 0x0000
          SET PC, page_find_free_skip

      ADD SP, 1
      SET PC, page_find_free_end

:page_find_free_skip
      ADD A, 1
      SET PC, page_find_free_found_loop


; Allocates a page for the current application
; A <- Address of the allocated memory page.
:page_alloc
      SET PUSH, B

      JSR page_find_free
      IFE A, 0
          SET PC, page_alloc_error

      SET PUSH, A

      JSR proc_id
      SET B, A ; proc_id
      SET A, PEEK ; free page number

      JSR page_combine
      JSR page_add
      IFE A, 0
          SET PC, page_alloc_error2

      SET A, POP

	  ; Calculate the real mem address of the allocated page.
      MUL A, 1024

:page_alloc_end
      SET B, POP
      SET PC, POP

:page_alloc_error2
      SET A, POP

:page_alloc_error
      SET A, 0
      SET PC, page_alloc_end

; Frees the given page for the current application
; A: memory
:page_free

      SET PC, page_free

      SET PUSH, A
      SET PUSH, B
      SET PUSH, C

      SET B, A
      MOD B, 1024
      SUB A, B
      SET C, A

      JSR proc_id
      SET B, A
      SET A, C

      JSR page_combine
      SET PUSH, A
      SET A, page_table

:page_free_loop
      SET B, [A]
      AND B, 0x3FFF
      IFE B, PEEK
          SET PC, page_free_found
      ADD A, 1
      IFN A, page_table_end
          SET PC, page_free_loop

:page_free_end
      SET A, POP
      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

:page_free_found
      SET [A], 0x0000

      ADD SP, 3
      SET A, PEEK
      SUB SP, 3

      JSR page_unset_map

      SET PC, page_free_end


; Deallocate all pages belonging to the process
; A -> proc_id (or proc info structure)
:page_free_of
      SET PUSH, A
      SET PUSH, B
      SET PUSH, C

      AND A, 0x00FF
      SET PUSH, A
      SET C, page_table

:page_free_of_loop
      SET A, [C]
      JSR page_decombine

      ; check the proc id
      IFN B, PEEK
          SET PC, page_free_of_loop_skip

      ; found page associated with the process - free it in page_table
      SET [C], 0x0000
      ; unset the page bit in page_map (page number is in A after decombine)
      JSR page_unset_map

:page_free_of_loop_skip
      ADD C, 1
      IFN C, page_table_end
          SET PC, page_free_of_loop

      ADD SP, 1

      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

; A: page num
:page_set_map
      SET PUSH, A
      SET PUSH, B

      SET B, 0x0001

      IFG 16, A
          SET PC, page_set_map_0
      IFG 32, A
          SET PC, page_set_map_1
      IFG 48, A
          SET PC, page_set_map_2

      SUB A, 48
      SHL B, A
      BOR [page_map3], B

:page_set_map_end
      SET B, POP
      SET A, POP
      SET PC, POP

:page_set_map_0
      SHL B, A
      BOR [page_map0], B
      SET PC, page_set_map_end

:page_set_map_1
      SUB A, 16
      SHL B, A
      BOR [page_map1], B
      SET PC, page_set_map_end

:page_set_map_2
      SUB A, 32
      SHL B, A
      BOR [page_map2], B
      SET PC, page_set_map_end


; A: page num
:page_unset_map
      SET PUSH, A
      SET PUSH, B

      SET B, 0x0001

      IFG 16, A
          SET PC, page_unset_map_0
      IFG 32, A
          SET PC, page_unset_map_1
      IFG 48, A
          SET PC, page_unset_map_2

      SUB A, 48
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map3], B

:page_unset_map_end
      SET B, POP
      SET A, POP
      SET PC, POP

:page_unset_map_0
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map0], B
      SET PC, page_unset_map_end

:page_unset_map_1
      SUB A, 16
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map1], B
      SET PC, page_unset_map_end

:page_unset_map_2
      SUB A, 32
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map2], B
      SET PC, page_unset_map_end

; Returns the amount of reserved memory
:page_check
      SET PUSH, B

      SET B, page_table
      SET A, 0

:page_check_loop
      IFN [B], 0
          ADD A, 1024
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_check_loop

      SET B, POP
      SET PC, POP


:page_check_of
      SET PUSH, B
      SET PUSH, C
      SET PUSH, A

      SET B, page_table
      SET A, 0

:page_check_of_loop
      SET C, [B]
      AND C, 0x00FF
      IFE C, PEEK
          ADD A, 1024
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_check_of_loop

      ADD SP, 1
      SET C, POP
      SET B, POP
      SET PC, POP


; ##############################################################

; Returns the version of AtlasOS
; Takes: ---
; Returns:
; A: main version
; B: subversion
; C: fixversion
:os_version
      SET A, [os_version_main]
      SET B, [os_version_sub]
	  SET C, [os_version_fix]
	  SET PC, POP

; Returns the ID of the current process
; Takes: ---
; Returns:
; A: process ID
:proc_id
      SET A, [proc_current]
      SET PC, POP

; Returns the start address of the current process
; Takes: ---
; Returns:
; A: start address
:proc_get_addr
      JSR proc_id

:proc_get_addr_of
      JSR proc_get_info

      ADD A, 10
      SET A, [A]
      SET PC, POP

; Returns the flags of the current process
; Takes: ---
; Returns:
; A: flags
:proc_get_flags
      JSR proc_id

:proc_get_flags_of
      JSR proc_get_info_of

      ADD A, 11
      SET A, [A]
      SET PC, POP

; Returns the address of the process info structure
; Takes: ---
; Returns:
; A: address
:proc_get_info
      JSR proc_id

:proc_get_info_of
      MUL A, 12
      ADD A, proc_buffer
      SET PC, POP

; Sets the flags of the current process
; Takes:
; A: flags
; Returns: ---
:proc_set_flags
      SET PUSH, A
      JSR proc_get_info
      ADD A, 11
      IFN A, 11
          SET [A], PEEK
      SET A, POP
      SET PC, POP

; Sets the flags of a process
; Takes:
; A: process ID
; B: flags
; Returns: ---
:proc_set_flags_of
      SET PUSH, A
      JSR proc_get_info_of
      ADD A, 11
      IFN A, 11
          SET [A], B
      SET A, POP
      SET PC, POP

; Sets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_set_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      BOR A, 0x0001
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Resets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_reset_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      AND A, 0xFFFE
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Toggles the active flag of the process
; Takes:
; A: process ID
; Returns:
; A: 1 - active, 0 - inactive
:proc_flag_is_active_of
      JSR proc_get_flags_of
      AND A, 0x0001
      SET PC, POP

; Generates a list of all process IDs and hands it over to a callback-function
; Takes:
; A: address of the callback-function (Takes: A: process ID, Returns: ---)
; Returns: ---
:proc_callback_list
      SET PUSH, B
      SET PUSH, A

      SET B, proc_table

:proc_callback_list_loop
      SET A, [B]
      IFN A, 0
          JSR PEEK
      ADD B, 12
      IFN B, proc_table_end
          SET PC, proc_callback_list_loop

      SET A, POP
      SET B, POP
      SET PC, POP

; proc_suspend
:proc_suspend
      SET [proc_buffer], [proc_current] ; Buffer the registers of the current process
      SET [proc_buffer_a], A
      SET [proc_buffer_b], B
      SET [proc_buffer_c], C
      SET [proc_buffer_x], X
      SET [proc_buffer_y], Y
      SET [proc_buffer_z], Z
      SET [proc_buffer_i], I
      SET [proc_buffer_j], J
      SET [proc_buffer_sp], SP

      ; Restore the Stackpointer so we can call subroutines
      SET SP, [proc_table10]

      ; Copy the buffered state to the table
      JSR proc_get_info
      SET B, A
      SET A, proc_buffer

      SET C, 12

      JSR mem_copy

      ; Process saved, now restore the next proc
      SET A, B

:proc_kill_me_hook
      ADD A, 12
:proc_suspend_loop
      IFE A, proc_table_end
          SET A, proc_table
      SET X, [A]
      IFN X, 0x0000
          SET PC, proc_suspend_invoke
      ADD A, 12
      SET PC, proc_suspend_loop

:proc_suspend_invoke
      ; Copy the process information to the registers
      SET B, proc_buffer
      JSR mem_copy

      SET [proc_current], [proc_buffer]
      SET A, [proc_buffer_a]
      SET B, [proc_buffer_b]
      SET C, [proc_buffer_c]
      SET X, [proc_buffer_x]
      SET Y, [proc_buffer_y]
      SET Z, [proc_buffer_z]
      SET I, [proc_buffer_i]
      SET J, [proc_buffer_j]
      SET SP, [proc_buffer_sp]
      SET PC, POP ; Jump into the Programm

; Loads a new process into memory
; A: Begin of the BLOB
; B: Length of the BLOB
:proc_load

	SET PUSH, B
	SET PUSH, C
	SET PUSH, X
	SET PUSH, Y
	SET PUSH, Z
	SET PUSH, I
	SET PUSH, J

	SET C, 0 ; Clear this out because C might contain flag info if we load an ABI exe

	SET Z, [A]
	IFN [A], 0x4714  ; Check for magic number
		SET PC, proc_load_start
:proc_load_handle_exec
	ADD A, 1
	;SET C, [A] ; Do nothing with the revision # in this interim build
	ADD A, 1
	SET I, [A] ; Save the length of the header
	ADD A, 1
	SET J, [A] ; Save the length of the code+data
	ADD A, 1
	SET C, [A] ; Save the flags data
	SUB A, 4 ; And now move the pointer back to the start

:proc_load_start
	SET X, proc_table

:proc_load_loop
	IFE [X], 0x0000
		SET PC, proc_load_to

	ADD X, 12
	IFN X, proc_table_end
		SET PC, proc_load_loop

:proc_load_error
	SET A, 0
	SET PC, proc_load_end

; Load the process and fill the details in the proc_table.
; X -> addr of the empty proc_table record for this process
; A <- proc id
:proc_load_to
	; Calculate the ProcID by finding the proc_table record number (OS is 1).
	SET [X], X
	SUB [X], proc_table
	DIV [X], 12
	ADD [X], 1

	; X = ProcInfo Addr

	; Backup our flags
	SET PUSH, C

	; Finally load the Process - A is the source mem addr, B is length.
	SET C, B
	SET PUSH, A

	; Pretend the routine has been called by this not-yet-loaded process, so we can allocate memory.
	SET PUSH, [proc_current]
	SET [proc_current], [X]

	JSR page_alloc

	SET [proc_current], POP

	IFE A, 0
		SET PC, proc_load_error

	; Copy the program to the newly allocated memory.
	SET B, A ; Save the address of the new page
	SET A, PEEK ; Get back our original source address
	IFE Z, 0x4714
		ADD A, I ; If we are an ABI exe offset the copy destination by the size of the header
	IFE Z, 0x4714
		SET C, J ; If we are an ABI exe set the size to just the code length
	JSR mem_copy
	SET A, POP

	; Get the flags back.
	SET C, POP

	; Check if we have any flags to deal with
	IFN C, 0
		JSR proc_handle_flags

	SET A, [X] ; A return the ProcID
	; Fill the proc_table entry for this process.
	ADD X, 1 ; A
	SET [X], 0
	ADD X, 1 ; B
	SET [X], 0
	ADD X, 1 ; C
	SET [X], 0
	ADD X, 1 ; X
	SET [X], 0
	ADD X, 1 ; Y
	SET [X], 0
	ADD X, 1 ; Z
	SET [X], 0
	ADD X, 1 ; I
	SET [X], 0
	ADD X, 1 ; J
	SET [X], 0

	; Set the SP to the last byte of the allocated memory page (B+1023)
	ADD X, 1 ; SP
	SET [X], B
	ADD [X], 1023
	SET Y, [X] ; Save stack address for later.

	; Store the memory address of the process.
	ADD X, 1
	SET [X], B
	ADD X, 1 ; Flags
	BOR C, 0x0001 ; OR in the active flag. This will overwrite the ART flag but we don't care
	SET [X], C

	SET [Y], B ; "Push" the "return" address on the process stack - this is the beginning of the process program.

:proc_load_end
	SET J, POP
	SET I, POP
	SET Z, POP
	SET Y, POP
	SET X, POP
	SET C, POP
	SET B, POP
	SET PC, POP


:proc_handle_flags
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; If bit 1 is true then backup the character set data
	SET PUSH, A
	SET A, 0 ; Param for manage_charset to save charset data
	AND C, 0x0002
	IFE C, 1
		JSR manage_charset
	SET A, POP

	SET C, PEEK
	AND C, 0x0001 ; Check if the app has an ART
	IFE C, 1
		JSR proc_exec_process_relocation
:proc_handle_flags_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Handle the ART table for an application
; A -> Start of the ABI header (i.e. file start)
; B -> Copy of binary that we are modifying
:proc_exec_process_relocation
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	ADD A, 5
	SET C, [A] ; Get the number of entries in the relocaton table
:proc_exec_process_relocation_loop
	IFE C, 0
		SET PC, proc_exec_process_relocation_end
	SET PUSH, B
	SET PUSH, X
	SET X, B ; Store the program start location
	ADD A, 1 ; Increment to next entry in ART
	ADD B, [A] ; Add the ART offset to our pointer
	ADD [B], X ; Add the program start location to the program code
	SUB C, 1 ; Decrement our ART counter
	SET X, POP
	SET B, POP
	SET PC, proc_exec_process_relocation_loop
:proc_exec_process_relocation_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP


; Kill self
:proc_kill_me
	JSR proc_id ; Save process ID
	SET X, A
	JSR proc_get_info_of ; Save process info address
	SET Y, A
	ADD A, 10 ; Save memory page
	SET Z, [A]

	ADD A, 1 ; Move to the flags word
	SET A, [A] ; And retrieve the process flags
	AND A, 0x0002 ; Check if this was a foreground app
	IFE A, 1 ; Restore the character set. Since A is already 1 (restore charset) no need for extra ops here
		JSR manage_charset

	SET A, Y ; Delete the process info entry
	SET B, 12
	JSR mem_clear

	SET A, X
	JSR page_free_of

	SET A, Y ; Restore the pointer to the info entry
	SET C, 12
	SET PC, proc_kill_me_hook

:proc_kill
      SET PUSH, B
      SET PUSH, Y
      SET PUSH, Z
      SET PUSH, A

      JSR proc_get_info_of ; Save process info address
      SET Y, A
      ADD A, 10 ; Save memory page
      SET Z, [A]

      SET A, Y ; Delete the process info entry
      SET B, 12
      JSR mem_clear

      SET A, POP ; Free the process memory page
      JSR page_free_of ; ! It will not be cleared !

      SET Z, POP
      SET Y, POP
      SET B, POP
      SET PC, POP

; ##############################################################



; PUSHes all registers to the stack
:pusha
     SET [pushpop_buffer], POP ; Save jump-back-address

     SET PUSH, A
     SET PUSH, B
     SET PUSH, C
     SET PUSH, X
     SET PUSH, Y
     SET PUSH, Z
     SET PUSH, I
     SET PUSH, J

     SET PC, [pushpop_buffer] ; jump back

; POPs all registers from the stack
:popa
     SET [pushpop_buffer], POP ; Save jump-back-address

     SET J, POP
     SET I, POP
     SET Z, POP
     SET Y, POP
     SET X, POP
     SET C, POP
     SET B, POP
     SET A, POP

     SET PC, [pushpop_buffer] ; jump back

:pushpop_buffer dat 0x0000

; Charset functions
; Takes:
; A: 0 to save charset, 1 to restore charset
:manage_charset
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET C, A
	SET A, char_set
	SET B, 0x8180
:manage_charset_loop
	IFE A, char_set_end
		SET PC, manage_charset_end
	IFE C, 0
		SET [A], [B]
	IFG C, 0
		SET [B], [A]
	ADD A, 1
	ADD B, 1
	SET PC, manage_charset_loop
:manage_charset_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP


; Driver functions

; Registers a new keyboard buffer
; Takes:
; A: Address of the buffer
; B: Keyboard buffer flags (right now set to 1 to make buffer exclusive)
:keyboard_register
	SET PUSH, C
	SET PUSH, B
    SET PUSH, A

    SET C, keyboard_buffers

:keyboard_register_loop
    IFE [C], 0
        SET PC, keyboard_register_set
    ADD C, 1
    IFN C, keyboard_buffers_end
        SET PC, keyboard_register_loop

:keyboard_register_set
    SET [C], A
	IFE B, 1
		SET [keyboard_buffers_exclusive], A

:keyboard_register_end
    SET A, POP
	SET B, POP
	SET C, POP
    SET PC, POP


; Unregisters a keyboard buffer
; Takes:
; A: Address of the buffer
:keyboard_unregister
	SET PUSH, B
    SET PUSH, A

    SET B, keyboard_buffers

:keyboard_unregister_loop
    IFE [B], A
        SET PC, keyboard_unregister_unset
    ADD B, 1
    IFN B, keyboard_buffers_end
        SET PC, keyboard_unregister_loop
	SET PC, keyboard_unregister_end
:keyboard_unregister_unset
    SET [B], 0x0000

	; If this is the exclusive buffer, reset the exclusive global flag
	IFE A, [keyboard_buffers_exclusive]
		JSR keyboard_unregister_exclusive

:keyboard_unregister_end
    SET A, POP
	SET B, POP
    SET PC, POP

:keyboard_unregister_exclusive
	; Trigger a keyboard buffer update on any other register buffers
	SET [keyboard_oldvalue], 0xFFFF
	; And clear the exclusive data
	SET [keyboard_buffers_exclusive], 0
	SET PC, POP



; Returns whether there is an exclusive keyboard buffer active
:keyboard_is_exclusive_active
	SET A, 0
	IFN [keyboard_buffers_exclusive], 0
		SET A, 1
	SET PC, POP

; Wipes out all of the registered keyboard buffers
; CAUTION! This make break other running applications
:keyboard_unregister_all
	SET PUSH, A
	SET A, keyboard_buffers
:keyboard_unregister_all_loop
	IFE A, keyboard_buffers_end
		SET PC, keyboard_unregister_all_end
	SET [A], 0
	ADD A, 1
	SET PC, keyboard_unregister_all_loop
:keyboard_unregister_all_end
	SET A, POP
	SET PC, POP

; Registers a new message queue
; A -> Address of the message queue
; A <- 1 succeeded, 0 failed
:msg_queue_reg
    SET PUSH, B
    SET PUSH, C

    SET B, message_queue_table

:msg_queue_reg_loop
    SET C, [B]
    IFE C, 0
        SET PC, msg_queue_reg_found

    IFN B, message_queue_table_end
        SET PC, msg_queue_reg_loop

    SET A, 0        ; No free space in the queue

:msg_queue_reg_end
    SET C, POP
    SET B, POP
    SET PC, POP

:msg_queue_reg_found
    SET [1+B], A    ; Set message queue address
    JSR proc_id     ; Set message queue flags (process id)
    SHL A, 8
    SET [B], A
    SET A, 1
    SET PC, msg_queue_reg_end

; Removes the (all) message queue(s) of the calling application
:msg_queue_rem
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C

    JSR proc_id     ; Gets the ID of the calling process

    SET B, message_queue_table

:msg_queue_rem_loop
    SET C, [B]
    SHR C, 8
    IFN C, A
        SET PC, msg_queue_rem_skip

    SET [B], 0x0000
    SET [1+B], 0x0000

:msg_queue_rem_skip
    ADD B, 2

    IFN B, message_queue_table_end
        SET PC, msg_queue_rem_loop

    SET C, POP
    SET B, POP
    SET A, POP
    SET PC, POP

; Sends a message to all message queues
; A -> Message source
; B -> Message content
:msg_broadcast
    SET PUSH, C
    SET PUSH, Y
    SET PUSH, Z

    SET C, [message_queue_table]

:msg_broadcast_loop
    SET Y, [C]
    IFN Y, 0
        JSR msg_send_to
    ADD C, 2
    IFN C, message_queue_table_end
        SET PC, msg_broadcast_loop

    SET Z, POP
    SET Y, POP
    SET C, POP
    SET PC, POP

; Sends a message to a specific process
; A -> Message source
; B -> Message content
; C -> Addr of the entry of the message queue
:msg_send_to
    SET PUSH, A       ; Save registers
    SET PUSH, B
    SET PUSH, I
    SET PUSH, J
    SET PUSH, C

    SET I, [C]        ; Get the pointers
    SET J, I

    AND I, 0x0002     ; Is the queue full?
    IFE I, 0x0002
        SET PC, msg_send_to_end

    SET I, J          ; Restore I

    SHR I, 1          ; "decompress" the pointers
    SHR J, 4
    AND I, 0x000E
    AND J, 0x000E

    SET C, [1+C]      ; address of the message queue
    ADD I, C          ; address of the new entry

    SET [I], A        ; Write message to the queue
    SET [1+I], B

    SUB I, C          ; Calculate the new pointer
    ADD I, 2
    AND I, 0x000E

    SET C, POP

    AND [C], 0xFF03   ; delete the pointers
    IFE I, J          ; queue full?
        BOR [C], 0x0002

    SHL J, 4          ; "compress" the pointers
    SHL I, 1
    BOR I, J

    BOR [C], I        ; write the pointers

:msg_send_to_end
    SET J, POP        ; Restore registers
    SET I, POP
    SET B, POP
    SET A, POP
    SET PC, POP

; Gets the next message for the current process
; A <- Source of the message
; B <- Content of the message
:msg_get_message
    SET PUSH, X
    SET PUSH, Z

    JSR proc_id
    JSR msg_find_proc_addr ; Finds the address of the process' message queue structure

    IFE A, 0          ; There is no message queue for this process
        SET PC, msg_get_message_end

    SET Z, A

    SET X, [Z]             ; SET X the flags
    SHR X, 4               ; Calculate the read ptr
    AND X, 0x000E
    ADD X, [1+Z]

    SET A, [X]             ; Reads the message
    SET B, [1+X]
    SET [X], 0x0000        ; Removes the message
    SET [1+X], 0x0000

    SUB X, [1+Z]           ; Calculate the new read pointer
    ADD X, 2
    AND X, 0x000E
    SHL X, 4

    AND [Z], 0xFF1D        ; Delete old read pointer and queue full flag
    BOR [Z], X             ; Save the new read pointer

:msg_get_message_end
    SET Z, POP
    SET X, POP
    SET PC, POP

; Finds the addr of the message queue of a given process in the message queue table
; A -> process ID
; A <- addr (or 0 if not exists)
:msg_find_proc_addr
    SET PUSH, B
    SET PUSH, C

    SET B, A
    SHL B, 8
    SET A, message_queue_table

:msg_find_proc_addr_loop
    SET C, [A]
    AND C, 0xFF00
    IFE C, B
        SET PC, msg_find_proc_addr_end
    ADD A, 2
    IFN A, message_queue_table_end
        SET PC, msg_find_proc_addr_loop

    SET A, 0            ; Nothing found

:msg_find_proc_addr_end
    SET C, POP
    SET B, POP
    SET PC, POP



; Copies a string from a source to a destination
; A -> source address
; B -> destination address:strcpy
:strcpy
    SET PUSH, A
    SET PUSH, B

:strcpy_loop
    IFE [A], 0
        SET PC, strcpy_end
    SET [B], [A]
    ADD A, 1
    ADD B, 1
    SET PC, strcpy_loop

:strcpy_end
    SET B, POP
    SET A, POP
	SET PC, POP

; Copies a string from a source to a destination with length limitation
; Takes:
; A: source
; B: destination
; C: length
:strncpy
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C

    ADD C, B
:strncpy_loop1
    IFE [A], 0
        SET PC, strncpy_loop2
    SET [B], [A]
    ADD A, 1
    ADD B, 1
    IFE B, C
        SET PC, strncpy_end
    SET PC, strncpy_loop1

:strncpy_loop2
    SET [B], 0
    ADD B, 1
    IFN B, C
        SET PC, strncpy_loop2

:strncpy_end
    SET C, POP
    SET B, POP
    SET A, POP
SET PC, POP

; Compares strings and stores the result in C and O
; A=B => C=0, O=0
; A>B => C>0, O=0
; A<B => C>0, O>0
; Takes:
; A: source #1
; B: source #2
:strcmp
    SET PUSH, A
    SET PUSH, B
    SET O, 0
    SET C, 0
:strcmp_loop
    IFE [A], 0
        SET PC, strcmp_end
    IFN [A], [B]
        SET PC, strcmp_end
    ADD A, 1
    ADD B, 1
    SET PC, strcmp_loop

:strcmp_end
    SET C, [A]
    SUB C, [B]
    SET B, POP
    SET A, POP
    SET PC, POP

; Stores the length of a given string in B
; A: Address of the string buffer
:strlen
	SET PUSH, A

	SET B, 0
:strlen_loop
	IFE [A], 0
		SET PC, strlen_end
	ADD A, 1
	SET PC, strlen_loop
:strlen_end
	SET B, A
	SUB B, PEEK

	SET A, POP
	SET PC, POP

; Reads a line of chars from the keyboard
; A: String buffer address
; B: Length
; C: Keybuffer
:read_line
     SET PUSH, C
     SET PUSH, B
     SET PUSH, A

     JSR mem_clear ; Clear the buffer

     ADD B, A

:read_line_loop
	 JSR proc_suspend
     IFE [C], 0
         SET PC, read_line_skip
     IFE [C], 0xA ; \n
         SET PC, read_line_end
     IFE [C], 0xD ; \r
         SET PC, read_line_end
     IFE [C], 0x8
         SET PC, read_line_backspace
     IFE A, B
         SET PC, read_line_skip

     SET [A], [C]

; Put the character on-screen so the user can see what is being typed
; Maybe have this toggleable?
     SET PUSH, A
     SET PUSH, B
     SET B, [A]
     BOR B, 0x7400
     SET A, B
     SET B, [video_cur]
     SET [B], A
     ADD [video_cur], 1
     SET B, POP
     SET A, POP

     ADD A, 1

:read_line_skip
     SET PC, read_line_loop

:read_line_backspace
; Ensure we don't backspace past the beginning
     IFE A, PEEK
     SET PC, read_line_skip

     SET PUSH, A
     SET PUSH, B
     SUB [video_cur], 1
     SET B, [video_cur]
     SET [B], 0
     SET B, POP
     SET A, POP
     SUB A, 1
     SET PC, read_line_skip

;
:read_line_end
; Add the null terminator
     SET [A], 0
; Pop everything back out
     SET A, POP
     SET B, POP
     SET C, POP
     SET PC, POP

; Sleeps for some cycles
; TODO: Change this (or add a new func.) to wait for a specific number of CPU cycles
; A: number of process cycles to wait
:sleep
    IFE A, 0
		SET PC, POP
    SUB A, 1
    JSR proc_suspend
    SET PC, sleep

; Returns a randomized number in A
:rand
    MUL [entropy], 52265
    ADD [entropy], 135
    SET A, [entropy]
    SET PC, POP

; Takes a seed in A
:srand
	MUL A, 49763
	SHL A, 2
	XOR A, 1273
	SET [entropy], A
	SET PC, POP

; ########################################

; FILESYSTEM FUNCTIONS

; Return start of the filesystem
:filesystem_getfile_table
	SET A, files_table
	SET PC, POP

; Returns pointer to start of file entry in file table in C, returns 0 if file not found
; A: buffer containing file name
:filesystem_getfile
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A

	SET B, A

	JSR filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:filesystem_getfile_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, filesystem_getfile_end
	SUB X, 1

	ADD A, 2 ; Skip over the directory ID and flags
	JSR strcmp ; Check if the current filename (A) matches the original filename (B)
	IFE C, 0
		SET PC, filesystem_getfile_found
	ADD A, 18 ; Skip over the filename, start, and end

	SET PC, filesystem_getfile_loop
:filesystem_getfile_found
	SUB A, 2 ; Backs up the pointer to the start of the file entry
	SET C, A ; Sets C to the start of the entry

:filesystem_getfile_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP

; Returns pointer to start of file entry in file table in C, returns 0 if file not found
; A: Program start or directory ID
:filesystem_getfile_bystart
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A

	SET B, A

	JSR filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:filesystem_getfile_bystart_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, filesystem_getfile_bystart_end
	SUB X, 1

	ADD A, 18 ; Skip over the directory ID, flags, and filename
	IFE B, [A]
		SET PC, filesystem_getfile_bystart_found

	ADD A, 2 ; Skip over end and jump to next entry

	SET PC, filesystem_getfile_bystart_loop
:filesystem_getfile_bystart_found
	SUB A, 18 ; Backs up the pointer to the start of the file entry
	SET C, A ; Sets C to the start of the entry

:filesystem_getfile_bystart_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP

; ########################################

; Halts the CPU
:stop SET PC, stop

:data

; OS Variables
:os_version_main dat 0x0000
:os_version_sub dat 0x0005
:os_version_fix dat 0x0006

:video_mem dat 0x8000
:video_col dat 0x7000
:video_cur dat 0x8000
:video_clear dat 0x7020

:text_start dat "AtlasOS v0.5.5 starting... ", 0x00
:text_start_ok dat "OK", 0xA0, 0x00
:text_logo1 DAT "      ___   __   __", 0xA0
:text_logo2 DAT "     /   | / /_ / /____ ______", 0xA0
:text_logo3 DAT "    / /| |/ __// // __ `/ ___/", 0xA0
:text_logo4 DAT "   / ___ / /  / // /_/ (__  )", 0xA0
:text_logo5 DAT "  /_/  |_\\_/ /_/ \\__,_/____/", 0xA0
:text_logo6 DAT "         / __ \\/ ___/", 0xA0
:text_logo7 DAT "        / / / /\\__ \\", 0xA0
:text_logo8 DAT "       / /_/ /___/ /", 0xA0
:text_logo9 DAT "       \\____//____/", 0xA0, 0x00

; Bitmap of the OS-managed memory, occupied pages are marked by 1's.
; Total of 64kB of memory supported here - each word covers 16kB.
:page_map
:page_map0 dat 0x0000
:page_map1 dat 0x0000
:page_map2 dat 0x0000
:page_map3 dat 0x0000

; Table mapping memory pages to processes.
; Each word holds a page descriptor. Low byte encodes proc id, high byte encodes
; the memory offset of the associated 1kB page. For example 0x0702 marks the memory area
; from 0x1C00 to 0x1FFF (7th page) as belonging to process 2.
:page_table              ; 128 words
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:page_table_end

:message_queue_table     ; 32 words
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:message_queue_table_end

:proc_current dat 0x0001
:proc_buffer dat 0x0000
:proc_buffer_a dat 0x0000
:proc_buffer_b dat 0x0000
:proc_buffer_c dat 0x0000
:proc_buffer_x dat 0x0000
:proc_buffer_y dat 0x0000
:proc_buffer_z dat 0x0000
:proc_buffer_i dat 0x0000
:proc_buffer_j dat 0x0000
:proc_buffer_sp dat 0x0000
:proc_buffer_mem dat 0x0000
:proc_buffer_flags dat 0x0000
:proc_table
       dat 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_table10
       dat 0xFFFF, 0x0000, 0xFFFD ; OS-Proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 1st proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 2nd proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 3rd proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 4th proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 5th proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; [...]
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_table_end

; Keyboard driver variables
:keyboard_buffers
dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:keyboard_buffers_end
:keyboard_buffers_flags
dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:keyboard_buffers_flags_end
:keyboard_buffers_exclusive dat 0x0000 ; Contains buffer mem loc that has exclusive access
:keyboard_oldvalue dat 0x0000

; Kernel watchdog variables
:kernel_watchdog_proc_list_buffer
	dat 0x0000, 0x0000
:kernel_watchdog_proc_list_buffer_end

; This is used to buffer the character set before a foreground application is loaded
; and to restore it after the app has closed
; This will allow foreground applications to alter the character set without impacting
; applications that will run after the foreground app has closed
:char_set
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:char_set_end
:screen_buffer_exclusive dat 0x0000

:entropy dat 0x0000

:api_start ; API starts at 0x1000
    dat os_version		; 0x1000 Returns the version of AtlasOS

    dat proc_id 		; 0x1001 Returns the ID of the current process
    dat proc_suspend 	        ; 0x1002 Suspends the process and starts the next
    dat proc_get_addr 	        ; 0x1003 Returns the address of the current processes memory
    dat proc_get_flags          ; 0x1004 Returns the flags of the current process
    dat proc_kill_me 	        ; 0x1005 Kills the current process
    dat proc_kill 		; 0x1006 Kills a process
    dat proc_load		; 0x1007 Loads a new process
    dat 0x0000                  ; 0x1008 Loads a new ABI process
    dat proc_callback_list      ; 0x1009 Dumps a list of running processes

    dat msg_queue_reg           ; 0x100A Registers a new message queue
    dat msg_queue_rem           ; 0x100B Removes a message queue
    dat msg_broadcast           ; 0x100C Broadcasts a message
    dat 0x0000                  ; 0x100D Not implemented yet: msg_send
    dat msg_get_message         ; 0x100E Receives the nest message in the queue

    dat page_alloc 		; 0x100F Allocates another 1024 words
    dat page_free 		; 0x1010 Frees allocated memory
    dat page_check		; 0x1011 Returns the amount of reserved memory
    dat page_check_of           ; 0x1012 Returns the amount of reserved memory per process

    dat mem_copy                ; 0x1013 Copies memory
    dat mem_clear 		; 0x1014 Clears memory

    dat pusha 			; 0x1015 Pushes all registers to the stack
    dat popa 			; 0x1016 Pops all registers from the stack

    dat strcpy 			; 0x1017 Copies a string
    dat strncpy 		; 0x1018 Copies a string with length limitation
    dat strlen 			; 0x1019 Returns the length of a null-terminated string
    dat strcmp 			; 0x101A Compares two null-terminated strings to see if they're equal

    dat int2dec 		; 0x101B Converts a value into the decimal representation
    dat int2hex 		; 0x101C Converts a value into the hexadecimal representation
    dat atoi 			; 0x101D Converts a textual, decimal number into the actual integer value

    dat text_out 		; 0x101E Displays a text on the screen
    dat newline 		; 0x101F Linefeed
    dat scroll 			; 0x1020 Scrolls the screen one line
    dat clear 			; 0x1021 Clears the screen
    dat char_put 		; 0x1022 Puts a char on the screen
    dat read_line 		; 0x1023 Reads a line from the keyboard to a buffer

    dat rand 			; 0x1024 Gets a random number
    dat srand			; 0x1025 Initializes the random number generator

    dat keyboard_register       ; 0x1026 Registers a specific memory location as keyboard buffer
    dat keyboard_unregister     ; 0x1027 Unregisters a specific memory location
    dat keyboard_is_exclusive_active ; 0x1028 Checks if exclusive keyboard is active

    dat filesystem_getfile           ; Returns the start of the matched filesystem entry in C, 0 otherwise
    dat filesystem_getfile_table     ; Returns the start of the filesystem file table. May be deprecated later
    dat filesystem_getfile_bystart   ; Returns the start of the matched filesystem entry in C, 0 otherwise
:api_end

; API Padding. This is temporary to buffer the kernel so that the API space doesn't overwrite program code
; TODO: Need to find a way to pad the kernel up to 0x1400 dynamically
; 2560 words
:api_padding
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "

:kernel_end
; ################################
; ################################
:apps

; Note: This application table will ONLY contain built-in apps eventually
; This means that we will likely get rid of it once external storage is implemented by Notch
; application_table_format
; dat "name_of_app", 0, app_location, app_location_end
:application_table
:app1 dat "AtlasText", 0, AtlasText, AtlasText_end
:app2 dat "AtlasShell", 0, AtlasShell, AtlasShell_end
:application_table_end


; BASH-like Process
:AtlasShell
	SET A, text_versionoutput
	JSR [0x101E]
:AtlasShell_start
	; Register our buffer with the driver
	SET A, input_buffer
	JSR [0x1026]
:AtlasShell_loop
	; First check if anything is taking exclusive keyboard access
	JSR [0x1028]
	IFN A, 0
		SET PC, AtlasShell_loop_wait

	; Load the pwd name
	JSR command_clear_present_working_directory_name
	SET A, [present_working_directory]
	JSR [0x102B]
	IFE C, 0
		SET PC, AtlasShell_skip_display_path
	ADD C, 2
	SET A, C
	SET B, present_working_directory_name
	JSR [0x1017]
	; Display the current path
	SET A, present_working_directory_name
	JSR [0x101E]
:AtlasShell_skip_display_path
	; Display the prompt
	SET A, text_prompt
	JSR [0x101E]

	; Reset the basics
	SET [ack_command], 0 ; reset command recognized

	; Read a line from the keyboard
	SET A, input_text_buffer
	SET B, 32
	SET C, input_buffer
	JSR [0x1023]

	; Skip everything if we got an empty line
	SET A, input_text_buffer
	JSR [0x1019]
	IFE B, 0
		SET PC, AtlasShell_loop_wait

	; Parse out the primary command
	SET A, input_text_buffer
	SET B, 0
	JSR shell_getparameter

	; Check for the 'clear' command
	SET A, command_clear
	SET B, command_parameter_buffer
	JSR [0x101A]
	IFE C, 0
		JSR command_clearf

	; Check for the 'version' command
	SET a, command_version
	SET b, command_parameter_buffer
	JSR [0x101A]
	IFE c, 0
	JSR command_versionf

	; Check for the 'load' command
	SET a, command_load
	SET b, command_parameter_buffer
	JSR [0x101A]
	IFE c, 0
	JSR command_loadf

	; Check for the 'kill' command
	SET a, command_kill
	SET b, command_parameter_buffer
	JSR [0x101A]
	IFE c, 0
	JSR command_killf

	; Check for the 'list' command
	SET a, command_list
	SET b, command_parameter_buffer
	JSR [0x101A]
	IFE c, 0
	JSR command_listf

	; Check for the 'ls' command
	SET A, command_ls
	SET B, command_parameter_buffer
	JSR [0x101A]
	IFE C, 0
		JSR command_lsf

	; Check for the 'cd' command
	SET A, command_cd
	SET B, command_parameter_buffer
	JSR [0x101A]
	IFE C, 0
		JSR command_cdf

	; Check if we're trying to run a file
	IFN [ack_command], 1
		JSR command_runfile

	; If we don't have an acknowledged command, display the generic response
	ifn [ack_command], 1
	JSR command_unknownf
:AtlasShell_loop_wait
	; Pause then loop back to start of process
	JSR [0x1002]
	SET PC, AtlasShell_loop
:AtlasShell_loop_end

; ==BEGIN COMMAND FUNCTIONS==
; Command function when we got an unknown command
:command_unknownf
	JSR [0x101F]
	SET a, text_unrecognized
	JSR [0x101E]
	SET pc, pop

; Command function to display version info
:command_versionf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Clear the param buffer
	SET A, command_parameter_buffer
	SET B, 16
	JSR [0x1014]
	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; Check if our param was blank
	SET A, command_parameter_buffer
	JSR [0x1019]
	IFE B, 0
		SET PC, command_versionf_shell

	; Check if our param was 'os' to give OS version
	SET A, command_version_os
	SET B, command_parameter_buffer
	JSR [0x101A]
	IFE C, 0
		SET PC, command_versionf_os
:command_versionf_shell
	JSR [0x101F]
	SET A, text_versionoutput
	JSR [0x101E]
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
:command_versionf_os
	JSR [0x101F]
	JSR command_os_version_display
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Command function to clear the screen
:command_clearf
	SET [ack_command], 1 ; acknowledge recognized command
	JSR [0x1021]
	SET pc, pop

; Command function to load a new process
:command_loadf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR command_clear_parameter_buffer

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; check if blank > load help
	SET A, command_parameter_buffer
	JSR [0x1019]
	IFE B, 0
		SET PC, command_loadf_help

	;check if list > list applications in table
	SET A, command_parameter_buffer
	SET B, command_list
	JSR [0x101A]
	IfE C, 0
		SET PC, command_loadf_list

	SET A, application_table

:command_loadf_loop
	IFE A, application_table_end ; if index is at the end of the table, we have an unknown app
		SET PC, command_loadf_unknown
	IFG A, application_table_end ; if index is at the end of the table, we have an unknown app
		SET PC, command_loadf_unknown
	SET B, command_parameter_buffer
	JSR [0x101A] ; compare table string to parameter
	IFE C, 0
		SET PC, command_loadf_loop_end ; if equal move to end

	; Get the length of the app name and move our pointer forward past that
	JSR [0x1019]
	ADD A, B
	; Skip past the null terminator, the start address, and the end address
	ADD A, 3
	SET PC, command_loadf_loop

:command_loadf_loop_end
	SET PUSH, A
	JSR [0x101F]
	SET A, command_parameter_buffer
	JSR [0x1019]
	SET A, POP
	ADD A, B
	ADD A, 1

	; Load the start & end addresses and start the process
	SET B, A
	ADD B, 1
	SET A, [A]
	SET B, [B]
	SUB B, A

	JSR [0x1007]

        IFE A, 0
            SET PC, command_loadf_unknown

	SET [last_proc], A
	SET PC, command_loadf_end

:command_loadf_help
	JSR [0x101F]
	SET A, command_load_help
	JSR [0x101E]
	SET PC, command_loadf_end

:command_loadf_list
	JSR command_clear_parameter_buffer ;clear parameter buffer so list command doesn't run afterwards
	JSR [0x101F]
	SET A, application_table
:command_loadf_list_loop
	IFE A, application_table_end ; if index is at the end of the table, finish listing apps
		SET PC, command_loadf_end
	IFG A, application_table_end ; if index is past end of the table, finish listing apps
		SET PC, command_loadf_end
	JSR [0x101E] ;print out app name
	JSR [0x101F]
	; Get the length of the app name and move our pointer forward past that
	JSR [0x1019]
	ADD A, B
	; Skip past the null terminator, the start address, and the end address
	ADD A, 3
	SET PC, command_loadf_list_loop ; loopback

:command_loadf_unknown
	JSR [0x101F]
	SET A, command_load_unknown
	JSR [0x101E]

:command_loadf_end
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [0x1002]
	SET PC, POP

; Command function to kill a running process
:command_killf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR command_clear_parameter_buffer

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; Check if our param was blank
	SET A, command_parameter_buffer
	JSR [0x1019]
	IFE B, 0
		SET PC, command_killf_help

	; Check if our param was 'last' to kill the last process
	SET A, command_kill_last
	SET B, command_parameter_buffer
	JSR [0x101A]
	IFE C, 0
		SET PC, command_killf_last

	; Convert the param to an integer
	SET A, command_parameter_buffer
	JSR [0x101D]	; A is source, C is result

	; Selfkill?
	SET PUSH, A
	JSR [0x1001]
	IFE A, C      ; Wants to kill me?
		SET PC, AtlasShell_die
	SET A, POP

	; Trying to kill OS?
	IFE C, 1
		SET PC, command_killf_forbidden

	; Kill the corresponding process
	JSR [0x101F]
	SET A, C
	JSR [0x1006]
	SET PC, command_killf_end
:command_killf_forbidden
	JSR [0x101F]
	SET A, command_kill_forbidden
	JSR [0x101E]
	SET PC, command_killf_end
:command_killf_last
	JSR [0x101F]
	SET A, [last_proc]
	JSR [0x1006]
	SET PC, command_killf_end
:command_killf_help
	JSR [0x101F]
	SET A, command_kill_help
	JSR [0x101E]
:command_killf_end
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [0x1002]
	SET PC, POP

; Command function to list process IDs
:command_listf
	SET [ack_command], 1
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Clear the process ID buffer first
	SET A, proc_list_buffer
:command_listf_clear_proc_list
	IFE A, proc_list_buffer_end
		SET PC, command_listf_end
	SET [A], 0
	ADD A, 1
	SET PC, command_listf_clear_proc_list

:command_listf_end
	; Get the process ID list
	SET C, proc_list_buffer
	SET A, command_listf_helper
	JSR [0x1009]

	JSR [0x101F]
	SET A, command_list_info
	JSR [0x101E]
	SET A, 0 ; OS process
	JSR command_listf_display_procID
	SET A, 1 ; Shell process
	JSR command_listf_display_procID
	SET A, 2
	JSR command_listf_display_procID
	SET A, 3
	JSR command_listf_display_procID
	SET A, 4
	JSR command_listf_display_procID
	SET A, 5
	JSR command_listf_display_procID

	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
:command_listf_helper
	SET [C], A
	ADD C, 1
	SET PC, POP
:command_listf_display_procID
	JSR command_clear_number_buffer

	; Now display the list on-screen
	SET B, proc_list_buffer
	ADD B, A
	SET A, [B]
	; Don't display if it's 0
	IFE A, 0
		SET PC, POP
	; Convert to text and display
	SET B, command_number_buffer
	JSR [0x101B]
	SET A, command_number_buffer
	JSR [0x101E]
	JSR [0x101F]

	SET PC, POP

; Command to list all files in current directory
:command_lsf
	SET [ack_command], 1
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET PUSH, X
	SET PUSH, Y
	JSR [0x101F]
	JSR [0x102A]
	SET X, [A]
	SET Y, 0
	ADD A, 1
:command_lsf_loop
	IFE Y, X
		SET PC, command_lsf_end
	ADD Y, 1
	SET B, command_ls_row

	SET PUSH, A
	SET C, [A] ; Ignore the directory value for now, will be finished later
	SET A, [present_working_directory]
	IFN C, A
		SET PC, command_lsf_skip_file
	SET A, POP

	ADD A, 1 ; Move on to flags

	; Store if this file can be read
	SET C, [A]
	AND C, 0x0001
	IFE C, 1
		SET [B], 0x52 ; 'R'
	ADD B, 1

	; Store if this file can be written to
	SET C, [A]
	AND C, 0x0002
	IFE C, 2
		SET [B], 0x57 ; 'W'
	ADD B, 1

	; Store if this file is executable
	SET C, [A]
	AND C, 0x0008
	IFE C, 8
		SET [B], 0x45 ; 'E'
	ADD B, 1

	; Check if the file is hidden
	SET C, [A]
	AND C, 0x0004
	IFE C, 4
		SET [B], 0x48 ; 'H'

		; Store if this is a directory
	SET C, [A]
	AND C, 0x0010
	IFE C, 16
		SET [B], 0x44 ; 'D'
	ADD B, 1

	; Add separator
	SET [B], 0x7C ; '|'
	ADD B, 1
	ADD A, 1

	; Store the file name
	JSR [0x1017]
	ADD B, 16
	ADD A, 16

	; Add separator
	SET [B], 0x7C ; '|'
	ADD B, 1
	;ADD A, 1

	IFE C, 16
		SET PC, command_lsf_skip_filesize

	; Display file size
	SET C, [A] ; Get the file start
	ADD A, 1
	SET PUSH, A
	SET A, [A]
	SUB A, C
	JSR [0x101B]
	SET A, POP
:command_lsf_skip_filesize
	IFE C, 16
		ADD A, 1
	; Output the file info
	SET C, A
	SET A, command_ls_row
	JSR [0x101E]
	SET A, C
	SET PC, command_lsf_skip_file_end
:command_lsf_skip_file
	SET A, POP
	ADD A, 19
:command_lsf_skip_file_end
	; Clear out the row buffer
	SET C, command_ls_row
	ADD C, 32
	SET B, command_ls_row
:command_lsf_clearrow
	SET [B], 0x20
	ADD B, 1
	IFN B, C
		SET PC, command_lsf_clearrow

	; Move on to the next entry
	ADD A, 1
	SET PC, command_lsf_loop
:command_lsf_end
	;JSR [0x1002]
	SET Y, POP
	SET X, POP
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

:command_runfile
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR [0x101F]

	SET A, command_parameter_buffer
	JSR [0x1029]
	IFE C, 0
		SET PC, command_runfile_end

	SET A, [C] ; Skip over the directory ID, will finish later
	IFN A, [present_working_directory]
		SET PC, command_runfile_end

	ADD C, 1
	SET A, [C] ; Get the file flags
	AND A, 0x0008 ; Check if the file is executable
	IFE A, 0
		SET PC, command_runfile_notexe

	ADD C, 1

	ADD C, 16
	SET A, [C]
	ADD C, 1
	SET B, [C]
	SUB B, A
	JSR [0x1007]
	IFN A, 0
		SET [ack_command], 1
	SET PC, command_runfile_end
:command_runfile_notexe
	SET A, command_runfile_notexe_text
	JSR [0x101E]
	SET [ack_command], 1
:command_runfile_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

:command_cdf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	JSR [0x101F]

	;check if 'cd'
	SET A, command_parameter_buffer
	SET B, command_cd
	JSR [0x101A]
	IFE C, 0
		SET PC, command_cdf_help

	; check if blank > load help
	SET A, command_parameter_buffer
	JSR [0x1019]
	IFE B, 0
		SET PC, command_cdf_help

	;check if '..'
	SET A, command_parameter_buffer
	SET B, command_cd_back
	JSR [0x101A]
	IFE C, 0
		SET PC, command_cdf_back

	;check if '/'
	SET A, command_parameter_buffer
	SET B, command_cd_root
	JSR [0x101A]
	IFE C, 0
		SET PC, command_cdf_root

	JSR [0x1029]
	IFN C, 0
		SET PC, command_cdf_cd
	SET PC, command_cdf_unknown

:command_cdf_help
	SET A, command_cd_help
	JSR [0x101E]
	SET PC, command_cdf_end

:command_cdf_back
	SET A, directory_stack_end
	SUB A, 1
:command_cdf_back_traverse_directorystack
	IFE A, directory_stack
		SET PC, command_cdf_back_end
	IFN [A], 0
		SET PC, command_cdf_back_end
	SUB A, 1
	SET PC, command_cdf_back_traverse_directorystack
:command_cdf_back_end
	SET [A], 0
	IFN A, directory_stack
		SUB A, 1
	SET [present_working_directory], [A]
	SET PC, command_cdf_end

:command_cdf_root
	SET [present_working_directory], 0x0000
	SET A, directory_stack
:command_cdf_root_clear_directorystack
	IFE A, directory_stack_end
		SET PC, command_cdf_end
	SET [A], 0
	ADD A, 1
	SET PC, command_cdf_root_clear_directorystack

:command_cdf_unknown
	SET A, command_parameter_buffer
	JSR [0x101E]
	SET A, command_cd_unknown
	JSR [0x101E]
	SET PC, command_cdf_end

:command_cdf_cd
	IFN [C], [present_working_directory] ; Check if we're trying to access a directory not in our current directory
		SET PC, command_cdf_unknown
	ADD C, 1 ; Move past to the flags
	SET A, [C]
	AND A, 0x0010 ; Check the flags to see if this file is a directory
	IFN A, 16
		SET PC, command_cdf_unknown
	ADD C, 1 ; Move to the name
	SET A, C

	ADD C, 16 ; Move past the name

	SET B, directory_stack
:command_cdf_cd_addtodirectorystack
	IFE B, directory_stack_end
		SET PC, command_cdf_end ; Directory stack is full, cannot change directory
	IFE [B], 0
		SET PC, command_cdf_cd_addtodirectorystack_end
	ADD B, 1
	SET PC, command_cdf_cd_addtodirectorystack
:command_cdf_cd_addtodirectorystack_end
	SET A, [C] ; Store the directory ID
	SET [B], A
	SET [present_working_directory], A

:command_cdf_end
	JSR command_clear_parameter_buffer
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [0x1002]
	SET PC, POP

:AtlasShell_die
	SET A, input_buffer
	JSR [0x1027]
	JSR [0x101F]
	JSR [0x1005]

; ==BEGIN HELPER FUNCTIONS==
; Displays OS version using API call to get version numbers
; TODO: Make the output more user-friendly
:command_os_version_display
	JSR command_clear_number_buffer
	SET A, 0
	SET B, 0
	SET C, 0
	; A - main version, B - sub version, C - fix version
	JSR [0x1000]
	SET PUSH, C
	SET PUSH, B
	MUL A, 10000
	SET B, command_number_buffer
	JSR [0x101B]
	IFE A, 0
		SET [B], 0x0030
	SET A, command_number_buffer
	SET B, POP
	SET A, B
	MUL A, 100
	SET B, command_number_buffer
	JSR [0x101B]
	SET A, command_number_buffer
	SET C, POP
	SET A, C
	SET B, command_number_buffer
	JSR [0x101B]
	SET A, command_number_buffer
	ADD A, 1
	SET [A], [command_version_separator]
	ADD A, 2
	SET [A], [command_version_separator]
	SET A, command_number_buffer
	JSR [0x101E]
	JSR [0x101F]
	SET PC, POP
; Clears the parameter buffer
:command_clear_parameter_buffer
	SET PUSH, A
	SET PUSH, B
	SET A, command_parameter_buffer
	SET B, 32
	JSR [0x1014]
	SET B, POP
	SET A, POP
	SET PC, POP
; Clears the number buffer
:command_clear_number_buffer
	; Empty the temp buffer
	SET PUSH, A
	SET A, command_number_buffer
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	SET A, POP
	SET PC, POP
:command_clear_present_working_directory_name
	SET PUSH, A
	SET PUSH, B
	SET A, present_working_directory_name
	SET B, 16
	JSR [0x1014]
	SET B, POP
	SET A, POP
	SET PC, POP

; Takes a command input and parses out a parameter
; A: Address of source text buffer
; B: Which param we want to parse out (starts at 0)
:shell_getparameter
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	; C will keep track of which param we're looking at
	SET C, 0
:shell_getparameter_loop
	IFE C, B
	SET PC, shell_getparameter_save
	IFE [A], 32
	ADD C, 1
	ADD A, 1
	IFE [A], 0
	SET PC, shell_getparameter_end
	SET PC, shell_getparameter_loop
:shell_getparameter_save
	SET B, command_parameter_buffer
:shell_getparameter_save_loop
	SET [B], 0
	IFE [A], 32
	SET PC, shell_getparameter_end
	IFE [A], 0
	SET PC, shell_getparameter_end
	IFE [A], 10
	SET PC, shell_getparameter_end
	SET [B], [A]
	ADD A, 1
	ADD B, 1
	SET PC, shell_getparameter_save_loop
:shell_getparameter_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Data
:input_text_buffer dat "                                ", 0x00
:input_buffer dat 0x0000
:ack_command dat 0x00
:command_clear dat "clear", 0
:command_version dat "version", 0
:command_version_os dat "os", 0
:command_version_separator dat ".", 0
:command_load dat "load", 0
:command_load_help dat "Syntax: load [appID]", 0xA0, 0x00
:command_load_unknown dat "Failed to load application", 0xA0, 0x00
:command_kill dat "kill", 0
:command_kill_forbidden dat "Cannot kill process: Forbidden", 0xA0, 0x00
:command_kill_help dat "Syntax: kill [last|procID]", 0xA0, 0x00
:command_kill_last dat "last", 0
:command_list dat "list", 0
:command_list_info dat "Process list:", 0xA0, 0x00
:command_parameter_buffer dat "                                ", 0x00
:command_number_buffer dat "     ", 0x00
:command_ls dat "ls", 0
:command_ls_row dat "                                ", 0x00
:command_cd dat "cd", 0
:command_cd_back dat "..", 0
:command_cd_root dat "/", 0
:command_cd_help dat "Syntax : cd [directory|..|/]", 0xA0, 0x00
:command_cd_unknown dat " doesnt exist", 0xA0, 0
:command_runfile_notexe_text dat "File is not executable", 0xA0, 0x00

:proc_list_buffer
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_list_buffer_end
:last_proc dat 0x0000

:text_unrecognized dat "Unrecognized command", 0xA0, 0x00
:text_versionoutput dat "Atlas-Shell v0.4.0", 0xA0, 0x00
:text_prompt dat " $> ", 0x00

:present_working_directory dat 0x0000
:present_working_directory_name dat "                ", 0x00
:directory_stack
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:directory_stack_end

:AtlasShell_end


; AtlasText - A simple, dummy text editor
:AtlasText
	JSR [AtlasText_clear]

	SET I, AtlasText_loop_end ; Calculate the length of the back-jump
	SUB I, AtlasText_loop

	; Register our buffer with the driver
	SET A, AtlasText_input_buffer
	; And ask for exclusive keyboard access
	SET B, 1
	JSR [AtlasText_keyboard_register]
:AtlasText_loop
	; If we hit ESC kill the editor
	IFE [AtlasText_input_buffer], 0x001B
		SET PC, AtlasText_die

	; Just print the text to the screen
	SET A, AtlasText_input_buffer
	JSR [AtlasText_text_out]

	JSR [AtlasText_proc_suspend]
	SUB PC, I
:AtlasText_loop_end
:AtlasText_die
	SET A, AtlasText_input_buffer
	JSR [AtlasText_keyboard_unregister]
	JSR [AtlasText_clear]
	JSR [AtlasText_proc_kill_me]
:AtlasText_data
	:AtlasText_input_buffer dat 0x0000, 0x0000
	; API Jump table
	:AtlasText_text_out dat 0x101C ; 14th index in API * 2 words long = 0x1C, text_out
	:AtlasText_proc_suspend dat 0x1004 ; 2nd index in API * 2 words long = 0x04, proc_suspend
	:AtlasText_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
	:AtlasText_keyboard_register dat 0x102A ; 21st index in API * 2 words long = 0x2A, keyboard_register
	:AtlasText_keyboard_unregister dat 0x102C ; 22nd index in API * 2 words long = 0x2C, keyboard_unregister
	:AtlasText_clear dat 0x1022 ; 17th index in API * 2 words long = 0x22, char_put
:AtlasText_end

:apps_end

:files

; Primary file table
; Flags: Bit 0 - read, Bit 1 - write, Bit 2 - hidden, Bit 3 - executable, Bit 4 - directory
; Each entry must be 20 words long
; directory ID, flags, name, null terminator, padding, start, end
; For directory entries, the 'start' contains the ID and the 'end' is unused
:files_table
	dat 0x000A ; Number of files in table
	dat 0xFFFF, 0x0011, "/", 0, "              ", 0x0000, 0x0000 ; root directory
	dat 0x0000, 0x0011, "TextFiles", 0, "      ", 0x0001, 0x0000
	dat 0x0000, 0x0011, "Programs", 0, "       ", 0x0002, 0x0000
	dat 0x0000, 0x0011, "Data", 0, "           ", 0x0004, 0x0000
	dat 0x0002, 0x0011, "System", 0, "         ", 0x0003, 0x0000
	dat 0x0001, 0x0003, "file01", 0, "         ", file01, file01_end
	dat 0x0002, 0x0009, "hello_world", 0, "    ", file02, file02_end
	dat 0x0003, 0x0009, "free_mem", 0, "       ", file03, file03_end
	dat 0x0001, 0x0005, "file04", 0, "         ", file04, file04_end
	dat 0x0002, 0x0009, "ball_game", 0, "      ", file05, file05_end
:files_table_end

; Basic flat text file
:file01
	dat "This is some text from a file   "
	dat "Blah blah some more content     "
	dat "Termination", 0x00
:file01_end

; HelloWorld
; Description: Displays "Hello World"
:file02 ; AtlasOS ABI-compliant executable file
	dat 0x4714 ; Magic number indicating an AtlasOS ABI-comliant binary
	dat 0x0001 ; Revision 1 of the ABI
	dat 0x000A ; Length of header (5 base + 5 for ART)
	dat 0x0018 ; Length of the code and data
	dat 0x000B ; Flags 00000000 00001011
	dat 0x0004 ; ART length
	dat 0x0001, 0x0003, 0x0005, 0x0007 ; ART entries
	; Code
	dat 0x7C01, 0x0008, 0x7810, 0x0017, 0x7810, 0x0015, 0x7810, 0x0016
	; Data
	dat 0x0048, 0x0065, 0x006c, 0x006c, 0x006f, 0x0020, 0x0057, 0x006f, 0x0072, 0x006c, 0x0064, 0x00a0, 0x0000, 0x1004, 0x100A, 0x101C
:file02_end

; Free
; Description: Displays the amount of free memory in RAM
:file03 ; AtlasOS ABI-compliant executable file
	dat 0x4714 ; Magic number indicating an AtlasOS ABI-comliant binary
	dat 0x0001 ; Revision 1 of the ABI
	dat 0x000F ; Length of header (5 base + 10 for ART)
	dat 0x003A ; Length of the code and data
	dat 0x000D ; Flags 00000000 00001101
	dat 0x0009 ; ART length
	dat 0x0001, 0x0007, 0x0009, 0x000B, 0x0010, 0x0012, 0x0014, 0x0016, 0x0018 ; ART entries
	; Code
	dat 0x7810, 0x0039, 0x7c31, 0xffff, 0x0033, 0x0c01, 0x7c11, 0x0019, 0x7810, 0x0037, 0x7c11, 0x002b, 0x7c05, 0x0400, 0x8407, 0x7810
	dat 0x0037, 0x7c01, 0x0019, 0x7810, 0x0036, 0x7c01, 0x0019, 0x7810, 0x0038
	; Data
	dat 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0077, 0x006f, 0x0072, 0x0064, 0x0073, 0x0020, 0x0066, 0x0072, 0x0065, 0x0065, 0x0020, 0x0028
	dat 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x004b, 0x0042, 0x0029, 0x00a0, 0x0000
	dat 0x101c, 0x102e, 0x100a, 0x1038
:file03_end

:file04
	dat "I am hidden, muahaha!", 0x00
:file04_end

; Ball
; Description: Runs a "ball" around on the screen and bounces off of walls
:file05 ; AtlasOS ABI-compliant executable file
	dat 0x4714 ; Magic number indicating an AtlasOS ABI-comliant binary
	dat 0x0001 ; Revision 1 of the ABI
	dat 0x000D ; Length of header (5 base + 8 for ART)
	dat 0x003F ; Length of the code and data ( 63 words )
	dat 0x000D ; Flags 00000000 00001101
	dat 0x0007 ; ART length ( 7 entries )
	dat 0x0021, 0x0027, 0x0029, 0x002E, 0x0035, 0x0037, 0x003A
	; Code
	dat 0x7C61, 0x0039, 0x7C63, 0x000A, 0x8001, 0x8011, 0x8431, 0x8441
	dat 0x7C71, 0x0064, 0x0C02, 0x1012, 0xFC0C, 0x7C31, 0xFFFF, 0xAC1C
	dat 0x7C41, 0xFFFF, 0x800C, 0x8431, 0x801C, 0x8441, 0x05A1, 0x7C14
	dat 0x0020, 0x0012, 0x7C12, 0x8000, 0x2451, 0x6011, 0x8473, 0x807C
	dat 0x7C10, 0x0039, 0xA021, 0x09A1, 0x7C21, 0x7400, 0x7810, 0x003E
	dat 0x7810, 0x003C, 0x6021, 0x8423, 0x802D, 0x7DC1, 0x0023, 0x1421
	dat 0x802C, 0x91C2, 0x7C2D, 0x744F, 0x7810, 0x003E, 0x7810, 0x003C
	dat 0x19C3, 0x7810, 0x003D, 0x61C1, 0x1004, 0x100A, 0x1024
:file05_end

:files_end
