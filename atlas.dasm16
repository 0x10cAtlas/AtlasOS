; AtlasOS
; A multiprocess capable DCPU OS by Plusmid and Chessmaster42
; AtlasOS version 0.5.4
; Atlas-Shell version 0.3.3

:kernel_boot
; clear screen (for emulator)
JSR clear

; low level routines
; runs best in DCPU-16 Studio (http://badsector.github.com/dcpustud/)

; Display the logo
SET A, text_logo1
JSR text_out

; Bootmessage
SET A, text_start
JSR text_out

; Reserve kernel-memory
SET X, 0
:kernel_mem
IFG X, kernel_end
    SET PC, kernel_mem_end
SET A, X
JSR page_reserve
ADD X, 1024
SET PC, kernel_mem
:kernel_mem_end

; Reserve video-memory
SET A, 0x8000
JSR page_reserve

; Reserve stack-memory
SET A, 0xFFFF
JSR page_reserve

; Reserve the API space
SET A, 0x1000
JSR page_reserve

;Reserve application memory
SET A, apps
:apps_mem
IFG A, apps_end
    SET PC, apps_mem_end
SET X, A
JSR page_reserve
SET A, X
ADD A, 1024
SET PC, apps_mem
:apps_mem_end

;Reserve virtual filesystem memory
SET A, files
:files_mem
IFG A, files_end
    SET PC, files_mem_end
SET X, A
JSR page_reserve
SET A, X
ADD A, 1024
SET PC, files_mem
:files_mem_end

SET X, 0

; Copy the API.
SET B, 0x1000
SET A, api_start
SET C, api_end
SUB C, A
JSR mem_copy

; OS ready message
SET A, text_start_ok
JSR text_out

; Clear out a few things
SET [keyboard_buffers_exclusive], 0
SET [keyboard_oldvalue], 0
JSR keyboard_unregister_all

; The kernel constantly polls the keyboard.
:kernel_loop

	; Call the keyboard driver
	JSR driver_keyboard
	
	; Check if the kernel is the only running process, if so start the shell
	JSR kernel_watchdog_checkalone

    JSR proc_suspend
    SET PC, kernel_loop

:kernel_watchdog_checkalone
	SET PUSH, C
	SET PUSH, B
	SET PUSH, A

	SET C, kernel_watchdog_proc_list_buffer
	SET A, kernel_watchdog_helper
	JSR proc_callback_list
	SET C, kernel_watchdog_proc_list_buffer
	ADD C, 1
	IFE [C], 0
		JSR kernel_watchdog_loadshell

	; Clear the proc buffer
	SET C, kernel_watchdog_proc_list_buffer
	SET [C], 0
	ADD C, 1
	SET [C], 0

	SET A, POP
	SET B, POP
	SET C, POP
	SET PC, POP
:kernel_watchdog_helper
	IFE C, kernel_watchdog_proc_list_buffer_end
		SET PC, POP
	SET [C], A
	ADD C, 1
	SET PC, POP
:kernel_watchdog_loadshell
	; This is a workaround so the shell doesn't freak out
	; when there is no data in the keyboard buffer
	SET [keyboard_oldvalue], 0xFFFF
	; Now start the shell
	SET A, AtlasShell
	SET B, AtlasShell_end
	SUB B, AtlasShell
	JSR proc_load
	SET PC, POP

; START OF THE KEYBOARD DRIVER
:driver_keyboard
    SET PUSH, A
    SET PUSH, B
	SET PUSH, C
	
	SET C, 0x9000
	SET B, 0x0000
:driver_keyboard_ringbuffloop
	IFN [C], 0
		SET B, [C]
	SET [C], 0
	ADD C, 1
	IFN C, 0x9010
		SET PC, driver_keyboard_ringbuffloop
	SET [C], B

	; Skip the driver if the key value hasn't changed
	IFE [C], [keyboard_oldvalue]
		SET PC, driver_keyboard_end

    SET A, keyboard_buffers

	IFN [keyboard_buffers_exclusive], 0
		SET PC, driver_keyboard_exclusive

:driver_keyboard_loop
	; Check to see if we have a buffer registered at this spot
    IFN [A], 0
        JSR driver_keyboard_save_to_buffer
	; Increment to the next buffer as long as we aren't at the end
    ADD A, 1
    IFN A, keyboard_buffers_end
        SET PC, driver_keyboard_loop
:driver_keyboard_end
	SET [keyboard_oldvalue], [C]
	SET [C], 0
	SET C, POP
	SET B, POP
    SET A, POP
    SET PC, POP

:driver_keyboard_exclusive
	SET B, [keyboard_buffers_exclusive]
	SET [B], [C]
	SET PC, driver_keyboard_end

:driver_keyboard_save_to_buffer
	SET B, [A]
	SET [B], [C]
	SET PC, POP

; END OF THE KEYBOARD DRIVER

SET PC, stop

; prints a text to stdout
; A: start address of the text
:text_out
      SET PUSH, A
      SET PUSH, B
      SET PUSH, C
      SET PUSH, I

      SET B, [video_col]
      SET I, [video_cur]

:text_out_loop
      SET C, [A]
      IFE C, 0x0000
          SET PC, text_out_end
      IFE C, 0x00A0
          SET PC, text_out_nl
      AND C, 0x00FF
      BOR C, B
      SET [I], C
      ADD A, 1
      ADD I, 1
      IFE I, 0x8180
          SET PC, text_out_scroll
      SET PC, text_out_loop

:text_out_scroll
      SET [video_cur], I
      JSR scroll
      SET I, [video_cur]
      SET PC, text_out_loop

:text_out_nl
      SET [video_cur], I
      JSR newline
      SET I, [video_cur]
      ADD A, 1
      SET PC, text_out_loop

:text_out_end
      SET [video_cur], I
      SET I, POP
      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

; Linefeed
:newline
      SET PUSH, A
      SET PUSH, B

      SET A, 0x0020
      SET B, [video_cur]
     ; SUB B, 0x8000
      MOD B, A
      SUB A, B
      ADD [video_cur], A
      IFE [video_cur], 0x8180
          JSR scroll

      SET B, POP
      SET A, POP
      SET PC, POP

; Scrolls the screen one line
:scroll
      SET PUSH, X
      SET PUSH, Y

      SET X, 0x8000 ; Set X to the video memory
      SET Y, 0x8020 ; Set Y to the second line in the video memory

:scroll_loop1
      SET [X], [Y]
      SET [1+X], [1+Y]
      SET [2+X], [2+Y]
      SET [3+X], [3+Y]

      ADD X, 4
      ADD Y, 4

      IFN Y, 0x8180
		SET PC, scroll_loop1

:scroll_loop2
      SET [X], [video_clear]
      ADD X, 1
      IFE X, 0x8180
          SET PC, scroll_end
      SET PC, scroll_loop2

:scroll_end
      SUB [video_cur], 0x20
      SET Y, POP
      SET X, POP
      SET PC, POP

; Clears the screen and sets the cursor to the first line (working)
:clear
      SET PUSH, A
      SET PUSH, B

      SET A, [video_mem]
      SET B, [video_clear]

:clear_loop
      SET [A], B
      SET [1+A], B
      SET [2+A], B
      SET [3+A], B
      ADD A, 4

      IFN A, 0x8180
          SET PC, clear_loop

:clear_end
      SET [video_cur], [video_mem]
      SET B, POP
      SET A, POP
      SET PC, POP

:get_pos
      SET PUSH, B

      IFG A, 31
          SET PC, get_pos_clip
      IFG B, 15
          SET PC, get_pos_clip

      MUL B, 32
      ADD B, 0x8000
      ADD B, A

      SET A, B

:get_pos_skip
      SET B, POP
      SET PC, POP

:get_pos_clip
      SET A, 0x0000
      SET PC, get_pos_skip


:char_put
      SET PUSH, A

      JSR get_pos
      SET [A], C

      SET A, POP
      SET PC, POP


; Converts a Number into a Decimal String
; A: Number
; B: StrBuffer (length 5)
:int2dec
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	ADD B, 4

:int2dec_loop
	SET C, A
	MOD C, 10

	SET [B], C
	ADD [B], 0x0030

	DIV A, 10
	SUB B, 1
	IFE A, 0
		SET PC, int2dec_end
	SET PC, int2dec_loop

:int2dec_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Converts a Number into a Hexadecimal String
; A: Number
; B: StrBuffer (length 4)
:int2hex
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	ADD B, 3

:int2hex_loop
	SET C, A
	AND C, 0x000F ; does the same thing as MOD, but AND takes one cycle, MOD takes 3

	SET [B], C
	ADD [B], 0x0030 ; adding 30 gives us a value of 30 to 3F
	IFG [B], 0x0039 ; if it's 3A or more, add seven
		ADD [B], 0x0007 ; giving us 30 - 39, 41 - 46

	DIV A, 16
	SUB B, 1
	IFE A, 0
		SET PC, int2hex_end
	SET PC, int2hex_loop

:int2hex_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Takes a text buffer containing an integer and converts it to an integer
; A: Address of text buffer
:atoi
     SET PUSH, A
     SET PUSH, B
     SET C, 0

:atoi_loop
     IFE [A], 0
     SET PC, atoi_end

     ; Capture the first digit and subtract 48 so our ASCII code for the digit becomes the numeric value of the digit
     SET B, [A]
     SUB B, 48

     ; Add the value of the digit to the accumulator
     ADD C, B

     ; Increment our address and multiply the accumulator
     ADD A, 1
     IFE [A], 0
     SET PC, atoi_end
     MUL C, 10
     SET PC, atoi_loop

:atoi_end
     SET B, POP
     SET A, POP
     SET PC, POP

; mem_clear
; A: From Addr
; B: Length
:mem_clear
      SET PUSH, A
      SET PUSH, B

      ADD B, A

:mem_clear_loop
      SET [A], 0
      ADD A, 1
      IFN A, B
          SET PC, mem_clear_loop

      SET B, POP
      SET A, POP
      SET PC, POP

; A: source
; B: dest
; C: length
:mem_copy
      SET PUSH, A
      SET PUSH, B
      SET PUSH, C

      ; Calulate the last address
      ADD C, A

:mem_copy_loop
      SET [B], [A]
      ADD A, 1
      ADD B, 1
      IFN A, C
          SET PC, mem_copy_loop

      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

; A: Mem addr of the page
:page_reserve
      SET PUSH, B

      SET B, A
      MOD B, 1024
      SUB A, B
      DIV A, 1024        ; Set the pagenum

      JSR page_remove    ; Remove all occurences of this page
      SET B, 0x0001      ; By the OS
      JSR page_combine   ; Combine A (the page num) and B (the proc id) to the page entry
      BOR A, 0x8000      ; Set the "reserved" flag
      JSR page_add

      SET B, POP
      SET PC, POP

; A: Removes all entries with the given page num
:page_remove
      SET PUSH, A
      SET PUSH, B

      AND A, 0x003F
      SHL A, 8
      SET PUSH, A

      SET B, page_table

:page_remove_loop
      SET A, [B]
      AND A, 0x3F00
      IFE A, PEEK
          SET [B], 0x0000     ; Remove entry
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_remove_loop

      SET A, POP              ; Remove a from stack
      SET B, POP              ; Restore registers
      SET A, POP
      SET PC, POP

; A -> page num
; B -> proc id
; A <- combined page entry
:page_combine
      SET PUSH, B

      AND A, 0x003F
      SHL A, 8
      AND B, 0x00FF
      BOR A, B

      SET B, POP
      SET PC, POP

; A -> combined page entry
; A <- page num
; B <- proc id
:page_decombine
      SET B, A

      SHR A, 8
      AND A, 0x003F
      AND B, 0x00FF

      SET PC, POP

; A -> page entry
; A <- 1 of succeeded, 0 if failed
:page_add
      SET PUSH, B
      SET B, page_table

:page_add_loop
      IFE [B], 0
          SET PC, page_add_set

      ADD B, 1
      IFN B, page_table_end
          SET PC, page_add_loop

      SET A, 0

:page_add_end
      SET B, POP
      SET PC, POP

:page_add_set
      SET [B], A

      JSR page_decombine
      JSR page_set_map

      SET A, 1
      SET PC, page_add_end

:page_find_free

      ;SET PC, page_find_free

      SET PUSH, B

      SET A, page_map
      SET B, 0
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found
      ADD A, 1
      ADD B, 1
      IFN [A], 0xFFFF
          SET PC, page_find_free_found

      ; Nothing found, exiting! (later: Swap)
      SET A, 0

:page_find_free_end
      SET B, POP
      SET PC, POP

:page_find_free_found
      SET PUSH, [A]
      MUL B, 16
      SET A, B

:page_find_free_found_loop
      SHR PEEK, 1
      IFN O, 0x0000
          SET PC, page_find_free_skip

      ADD SP, 1
      SET PC, page_find_free_end

:page_find_free_skip
      ADD A, 1
      SET PC, page_find_free_found_loop


; Allocates a page for the current application
:page_alloc
      SET PUSH, B

      JSR page_find_free
      IFE A, 0
          SET PC, page_alloc_error

      SET PUSH, A

      JSR proc_id
      SET B, A
      SET A, PEEK

      JSR page_combine
      JSR page_add
      IFE A, 0
          SET PC, page_alloc_error2

      SET A, POP
      MUL A, 1024

:page_alloc_end
      SET B, POP
      SET PC, POP

:page_alloc_error2
      SET A, POP

:page_alloc_error
      SET A, 0
      SET PC, page_alloc_end
	
; Variation of page_alloc that is used for proc_exec to pre-allocate memory space for a new process
:proc_exec_page_alloc
	SET PUSH, B

	JSR page_find_free
	IFE A, 0
		SET PC, page_alloc_error

	SET PUSH, A

	; B is passed in as the procID to associate this page
	; Therefore we don't call JSR proc_id
	SET A, PEEK

	JSR page_combine
	JSR page_add
	IFE A, 0
		SET PC, page_alloc_error2

	SET A, POP
	MUL A, 1024
	SET PC, page_alloc_end

; Frees the given page for the current application
; A: memory
:page_free

      SET PC, page_free

      SET PUSH, A
      SET PUSH, B
      SET PUSH, C

      SET B, A
      MOD B, 1024
      SUB A, B
      SET C, A

      JSR proc_id
      SET B, A
      SET A, C

      JSR page_combine
      SET PUSH, A
      SET A, page_table

:page_free_loop
      SET B, [A]
      AND B, 0x3FFF
      IFE B, PEEK
          SET PC, page_free_found
      ADD A, 1
      IFN A, page_table_end
          SET PC, page_free_loop

:page_free_end
      SET A, POP
      SET C, POP
      SET B, POP
      SET A, POP
      SET PC, POP

:page_free_found
      SET [A], 0x0000

      ADD SP, 3
      SET A, PEEK
      SUB SP, 3

      JSR page_unset_map

      SET PC, page_free_end


:page_free_of
      SET PUSH, A
      SET PUSH, B

      AND A, 0x00FF
      SET PUSH, A
      SET B, page_table

:page_free_of_loop
      SET A, [B]
      AND A, 0x00FF
      IFE A, PEEK
          SET [B], 0x0000
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_free_of_loop

      ADD SP, 1

      SET B, POP
      SET A, POP

; A: page num
:page_set_map
      SET PUSH, A
      SET PUSH, B

      SET B, 0x0001

      IFG 16, A
          SET PC, page_set_map_0
      IFG 32, A
          SET PC, page_set_map_1
      IFG 48, A
          SET PC, page_set_map_2

      SUB A, 48
      SHL B, A
      BOR [page_map3], B

:page_set_map_end
      SET B, POP
      SET A, POP
      SET PC, POP

:page_set_map_0
      SHL B, A
      BOR [page_map0], B
      SET PC, page_set_map_end

:page_set_map_1
      SUB A, 16
      SHL B, A
      BOR [page_map1], B
      SET PC, page_set_map_end

:page_set_map_2
      SUB A, 32
      SHL B, A
      BOR [page_map2], B
      SET PC, page_set_map_end


; A: page num
:page_unset_map
      SET PUSH, A
      SET PUSH, B

      SET B, 0x0001

      IFG 16, A
          SET PC, page_unset_map_0
      IFG 32, A
          SET PC, page_unset_map_1
      IFG 48, A
          SET PC, page_unset_map_2

      SUB A, 48
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map3], B

:page_unset_map_end
      SET B, POP
      SET A, POP
      SET PC, POP

:page_unset_map_0
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map0], B
      SET PC, page_unset_map_end

:page_unset_map_1
      SUB A, 16
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map1], B
      SET PC, page_unset_map_end

:page_unset_map_2
      SUB A, 32
      SHL B, A
      XOR B, 0xFFFF
      AND [page_map2], B
      SET PC, page_unset_map_end

; Returns the amount of reserved memory
:page_check
      SET PUSH, B

      SET B, page_table
      SET A, 0

:page_check_loop
      IFN [B], 0
          ADD A, 1024
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_check_loop

      SET B, POP
      SET PC, POP


:page_check_of
      SET PUSH, B
      SET PUSH, C
      SET PUSH, A

      SET B, page_table
      SET A, 0

:page_check_of_loop
      SET C, [B]
      AND C, 0x00FF
      IFE C, PEEK
          ADD A, 1024
      ADD B, 1
      IFN B, page_table_end
          SET PC, page_check_of_loop

      ADD SP, 1
      SET C, POP
      SET B, POP
      SET PC, POP


; ##############################################################

; Returns the version of AtlasOS
; Takes: ---
; Returns:
; A: main version
; B: subversion
; C: fixversion
:os_version
      SET A, [os_version_main]
      SET B, [os_version_sub]
	  SET C, [os_version_fix]
	  SET PC, POP

; Returns the ID of the current process
; Takes: ---
; Returns:
; A: process ID
:proc_id
      SET A, [proc_current]
      SET PC, POP

; Returns the start address of the current process
; Takes: ---
; Returns:
; A: start address
:proc_get_addr
      JSR proc_id

:proc_get_addr_of
      JSR proc_get_info

      ADD A, 10
      SET A, [A]
      SET PC, POP

; Returns the flags of the current process
; Takes: ---
; Returns:
; A: flags
:proc_get_flags
      JSR proc_id

:proc_get_flags_of
      JSR proc_get_info_of

      ADD A, 11
      SET A, [A]
      SET PC, POP

; Returns the address of the process info structure
; Takes: ---
; Returns:
; A: address
:proc_get_info
      JSR proc_id

:proc_get_info_of
      MUL A, 12
      ADD A, proc_buffer
      SET PC, POP

; Sets the flags of the current process
; Takes:
; A: flags
; Returns: ---
:proc_set_flags
      SET PUSH, A
      JSR proc_get_info
      ADD A, 11
      IFN A, 11
          SET [A], PEEK
      SET A, POP
      SET PC, POP

; Sets the flags of a process
; Takes:
; A: process ID
; B: flags
; Returns: ---
:proc_set_flags_of
      SET PUSH, A
      JSR proc_get_info_of
      ADD A, 11
      IFN A, 11
          SET [A], B
      SET A, POP
      SET PC, POP

; Sets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_set_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      BOR A, 0x0001
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Resets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_reset_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      AND A, 0xFFFE
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Toggles the active flag of the process
; Takes:
; A: process ID
; Returns:
; A: 1 - active, 0 - inactive
:proc_flag_is_active_of
      JSR proc_get_flags_of
      AND A, 0x0001
      SET PC, POP

; Generates a list of all process IDs and hands it over to a callback-function
; Takes:
; A: address of the callback-function (Takes: A: process ID, Returns: ---)
; Returns: ---
:proc_callback_list
      SET PUSH, B
      SET PUSH, A

      SET B, proc_table

:proc_callback_list_loop
      SET A, [B]
      IFN A, 0
          JSR PEEK
      ADD B, 12
      IFN B, proc_table_end
          SET PC, proc_callback_list_loop

      SET A, POP
      SET B, POP
      SET PC, POP

; proc_suspend
:proc_suspend
      SET [proc_buffer], [proc_current] ; Buffer the registers of the current process
      SET [proc_buffer_a], A
      SET [proc_buffer_b], B
      SET [proc_buffer_c], C
      SET [proc_buffer_x], X
      SET [proc_buffer_y], Y
      SET [proc_buffer_z], Z
      SET [proc_buffer_i], I
      SET [proc_buffer_j], J
      SET [proc_buffer_sp], SP

      ; Restore the Stackpointer so we can call subroutines
      SET SP, [proc_table10]

      ; Copy the buffered state to the table
      JSR proc_get_info
      SET B, A
      SET A, proc_buffer

      SET C, 12

      JSR mem_copy

      ; Process saved, now restore the next proc
      SET A, B

:proc_kill_me_hook
      ADD A, 12
:proc_suspend_loop
      IFE A, proc_table_end
          SET A, proc_table
      SET X, [A]
      IFN X, 0x0000
          SET PC, proc_suspend_invoke
      ADD A, 12
      SET PC, proc_suspend_loop

:proc_suspend_invoke
      ; Copy the process information to the registers
      SET B, proc_buffer
      JSR mem_copy

      SET [proc_current], [proc_buffer]
      SET A, [proc_buffer_a]
      SET B, [proc_buffer_b]
      SET C, [proc_buffer_c]
      SET X, [proc_buffer_x]
      SET Y, [proc_buffer_y]
      SET Z, [proc_buffer_z]
      SET I, [proc_buffer_i]
      SET J, [proc_buffer_j]
      SET SP, [proc_buffer_sp]
      SET PC, POP ; Jump into the Programm

; Loads a new process into memory
; A: Begin of the BLOB
; B: Length of the BLOB
:proc_load

      SET PUSH, B
      SET PUSH, C
      SET PUSH, X
      SET PUSH, Y
      SET PUSH, Z
	  
	  SET C, 0 ; Clear this out in case proc_exec is triggered because C will contain flag info

      IFE [A], 0x4714  ; Check for magic number
          SET PC, proc_exec     ; No flat binary, call advanced loader

:proc_load_start
      SET X, proc_table

:proc_load_loop
      IFE [X], 0x0000
          SET PC, proc_load_to

      ADD X, 12
      IFN X, proc_table_end
          SET PC, proc_load_loop

:proc_load_error
      SET A, 0

:proc_load_end
      SET Z, POP
      SET Y, POP
      SET X, POP
      SET C, POP
      SET B, POP
      SET PC, POP

:proc_load_to
	; Calculate the ProcID
	SET [X], X
	SUB [X], proc_table
	DIV [X], 12
	ADD [X], 1

	; Check if we have any flags to deal with
	IFN C, 0
		JSR proc_handle_flags
		
	SET PUSH, C

	; X = ProcInfo Addr

	; Finaly load the Process
	SET C, B
	SET Y, A

	SET Z, [proc_current]   ; Fake the process ID
	SET [proc_current], [X]

	JSR page_alloc

	SET [proc_current], z

	IFE A, 0
		SET PC, proc_load_error

	SET B, A
	SET A, Y
	JSR mem_copy
	
	SET C, POP

	SET A, [X] ; A return the ProcID

	ADD X, 1 ; A
	SET [X], 0
	ADD X, 1 ; B
	SET [X], 0
	ADD X, 1 ; C
	SET [X], 0
	ADD X, 1 ; X
	SET [X], 0
	ADD X, 1 ; Y
	SET [X], 0
	ADD X, 1 ; Z
	SET [X], 0
	ADD X, 1 ; I
	SET [X], 0
	ADD X, 1 ; J
	SET [X], 0
	ADD X, 1 ; SP
	SET [X], B
	ADD [X], 1023
	SET Y, [X] ; Save stack address
	ADD X, 1
	SET [X], B
	ADD X, 1 ; Flags
	BOR C, 0x0001 ; OR in the active flag. This will overwrite the ART flag but we don't care
	SET [X], C

	SET [Y], B ; "Push" the "return" address on the stack

	SET PC, proc_load_end

:proc_handle_flags
	SET PUSH, A
	SET PUSH, B
	
	; If bit 1 is true then backup the character set data
	SET A, 0 ; Param for manage_charset to save charset data
	SET B, C
	AND B, 0x0002
	IFE B, 1
		JSR manage_charset
		
	SET B, POP
	SET A, POP
	SET PC, POP



; Loads a new process into memory
; A: Begin of the BLOB
; B: Length of the BLOB
:proc_exec
	IFN [A], 0x4714     ; seems to be a flat binary, call legacy loader
		SET PC, proc_load

	SET PUSH, X
	SET PUSH, I
	SET PUSH, J
	
	; Allocate pages of memory and copy the program to the new memory
	; This is important because we don't want to modify the original
	; As the original may be read-only or not in RAM
	JSR proc_exec_prealloc_pages

	SET X, B ; Store the given length for error checking
	SET B, A ; Store the start point for error checking in a bit as the ABI format determines the BLOB length

	ADD A, 1
	SET C, [A] ; Do nothing with the revision # in this interim build
	ADD A, 1
	SET I, [A] ; Save the length of the header
	ADD A, 1
	SET J, [A] ; Save the length of the code+data
	ADD A, 1
	SET Y, [A] ; Save the flags data
	
	SET C, Y
	AND C, 0x0001 ; Check if the app has an ART
	IFE C, 1
		JSR proc_exec_process_relocation
:proc_exec_check_errors
	; Check that the calculated total size is what we got from the function call
	ADD I, J
	IFN I, X
		SET PC, proc_load_error
	SUB I, J ; Clean up I, takes less time than PUSH and POP
:proc_exec_prepare_pointers
	; Start loading the app
	; Must have code start in A, and length in B
	SET A, B
	ADD A, I
	SET B, J ; Copy code length that we got from header
	SET C, Y ; Save the flags
	
	SET J, POP
	SET I, POP
	SET X, POP
	
	SET PC, proc_load_start
:proc_exec_process_relocation
	; Check if the header length isn't enough to contain the ART with at least 1 entry
	IFG 7, I
		SET PC, proc_load_error ; We throw an error because the flags said there should be an ART

	ADD A, 1
	SET C, [A] ; Get the number of entries in the relocaton table
:proc_exec_process_relocation_loop
	IFE C, 0
		SET PC, POP
	SET PUSH, B
	SET PUSH, X
	ADD B, I ; Offset our pointer by the length of the header. This puts us at the start of the program code
	SET X, B ; Store the program start location
	ADD A, 1 ; Increment to next entry in ART
	ADD B, [A] ; Add the ART offset to our pointer
	ADD [B], X ; Add the program start location to the program code
	SUB C, 1 ; Decrement our ART counter
	SET X, POP
	SET B, POP
	SET PC, proc_exec_process_relocation_loop
	
:proc_exec_prealloc_pages
	SET PUSH, X
	SET PUSH, A ; Contains start of blob
	SET PUSH, B ; Contains blob size

	SET X, B ; Backup the blob size
	SET B, proc_table

:proc_exec_precalc_procid_loop
	IFE [B], 0x0000
		SET PC, proc_exec_precalc_procid_end

	ADD B, 12
	IFN B, proc_table_end
		SET PC, proc_exec_precalc_procid_loop
:proc_exec_precalc_procid_end
	; Calculate the ProcID
	SUB B, proc_table
	DIV B, 12
	ADD B, 1
	
	JSR proc_exec_page_alloc ; Allocate a page to the proposed proc ID
	SET PUSH, A
	SET PUSH, X
:proc_exec_prealloc_pages_add
	IFG 1024, X ; Check if our blob is too big to fit in one page
		SET PC, proc_exec_prealloc_pages_add_done
	JSR proc_exec_page_alloc ; Allocate a page to the proposed proc ID
	SUB X, 1024
	SET PC, proc_exec_prealloc_pages_add
:proc_exec_prealloc_pages_add_done
	SET X, POP
	SET A, POP
	SET C, POP ; Set the length for the copy
	SET B, A ; Set the destination at the start of the new page
	SET A, POP ; Set the source
	JSR mem_copy ; Copy the program to the new allocated memory
	
	SET A, B ; Set A to the new start location in the new memory
	SET B, X ; Set B back to the blob size we stored in X
:proc_exec_prealloc_pages_end
	SET X, POP
	SET PC, POP
	
	
; Kill self
:proc_kill_me
	JSR proc_id ; Save process ID
	SET X, A
	JSR proc_get_info_of ; Save process info address
	SET Y, A
	ADD A, 10 ; Save memory page
	SET Z, [A]

	ADD A, 1 ; Move to the flags word
	SET A, [A] ; And retrieve the process flags
	AND A, 0x0002 ; Check if this was a foreground app
	IFE A, 1 ; Restore the character set. Since A is already 1 (restore charset) no need for extra ops here
		JSR manage_charset

	SET A, Y ; Delete the process info entry
	SET B, 12
	JSR mem_clear

	SET A, X
	JSR page_free_of

	SET A, Y ; Restore the pointer to the info entry
	SET C, 12
	SET PC, proc_kill_me_hook

:proc_kill
      SET PUSH, B
      SET PUSH, Y
      SET PUSH, Z
      SET PUSH, A

      JSR proc_get_info_of ; Save process info address
      SET Y, A
      ADD A, 10 ; Save memory page
      SET Z, [A]

      SET A, Y ; Delete the process info entry
      SET B, 12
      JSR mem_clear

      SET A, POP ; Free the process memory page
      JSR page_free_of ; ! It will not be cleared !

      SET Z, POP
      SET Y, POP
      SET B, POP
      SET PC, POP

; ##############################################################



; PUSHes all registers to the stack
:pusha
     SET [pushpop_buffer], POP ; Save jump-back-address

     SET PUSH, A
     SET PUSH, B
     SET PUSH, C
     SET PUSH, X
     SET PUSH, Y
     SET PUSH, Z
     SET PUSH, I
     SET PUSH, J

     SET PC, [pushpop_buffer] ; jump back

; POPs all registers from the stack
:popa
     SET [pushpop_buffer], POP ; Save jump-back-address

     SET J, POP
     SET I, POP
     SET Z, POP
     SET Y, POP
     SET X, POP
     SET C, POP
     SET B, POP
     SET A, POP

     SET PC, [pushpop_buffer] ; jump back

:pushpop_buffer dat 0x0000

; Charset functions
; Takes:
; A: 0 to save charset, 1 to restore charset
:manage_charset
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET C, A
	SET A, char_set
	SET B, 0x8180
:manage_charset_loop
	IFE A, char_set_end
		SET PC, manage_charset_end
	IFE C, 0
		SET [A], [B]
	IFG C, 0
		SET [B], [A]
	ADD A, 1
	ADD B, 1
	SET PC, manage_charset_loop
:manage_charset_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP


; Driver functions

; Registers a new keyboard buffer
; Takes:
; A: Address of the buffer
; B: Keyboard buffer flags (right now set to 1 to make buffer exclusive)
:keyboard_register
	SET PUSH, C
	SET PUSH, B
    SET PUSH, A

    SET C, keyboard_buffers

:keyboard_register_loop
    IFE [C], 0
        SET PC, keyboard_register_set
    ADD C, 1
    IFN C, keyboard_buffers_end
        SET PC, keyboard_register_loop

:keyboard_register_set
    SET [C], A
	IFE B, 1
		SET [keyboard_buffers_exclusive], A

:keyboard_register_end
    SET A, POP
	SET B, POP
	SET C, POP
    SET PC, POP


; Unregisters a keyboard buffer
; Takes:
; A: Address of the buffer
:keyboard_unregister
	SET PUSH, B
    SET PUSH, A

    SET B, keyboard_buffers

:keyboard_unregister_loop
    IFE [B], A
        SET PC, keyboard_unregister_unset
    ADD B, 1
    IFN B, keyboard_buffers_end
        SET PC, keyboard_unregister_loop
	SET PC, keyboard_unregister_end
:keyboard_unregister_unset
    SET [B], 0x0000

	; If this is the exclusive buffer, reset the exclusive global flag
	IFE A, [keyboard_buffers_exclusive]
		JSR keyboard_unregister_exclusive

:keyboard_unregister_end
    SET A, POP
	SET B, POP
    SET PC, POP

:keyboard_unregister_exclusive
	; Trigger a keyboard buffer update on any other register buffers
	SET [keyboard_oldvalue], 0xFFFF
	; And clear the exclusive data
	SET [keyboard_buffers_exclusive], 0
	SET PC, POP



; Returns whether there is an exclusive keyboard buffer active
:keyboard_is_exclusive_active
	SET A, 0
	IFN [keyboard_buffers_exclusive], 0
		SET A, 1
	SET PC, POP

; Wipes out all of the registered keyboard buffers
; CAUTION! This make break other running applications
:keyboard_unregister_all
	SET PUSH, A
	SET A, keyboard_buffers
:keyboard_unregister_all_loop
	IFE A, keyboard_buffers_end
		SET PC, keyboard_unregister_all_end
	SET [A], 0
	ADD A, 1
	SET PC, keyboard_unregister_all_loop
:keyboard_unregister_all_end
	SET A, POP
	SET PC, POP

; Registers a new message queue
; A -> Address of the message queue
; A <- 1 succeeded, 0 failed
:msg_queue_reg
    SET PUSH, B
    SET PUSH, C

    SET B, message_queue_table

:msg_queue_reg_loop
    SET C, [B]
    IFE C, 0
        SET PC, msg_queue_reg_found

    IFN B, message_queue_table_end
        SET PC, msg_queue_reg_loop

    SET A, 0        ; No free space in the queue

:msg_queue_reg_end
    SET C, POP
    SET B, POP
    SET PC, POP

:msg_queue_reg_found
    SET [1+B], A    ; Set message queue address
    JSR proc_id     ; Set message queue flags (process id)
    SHL A, 8
    SET [B], A
    SET A, 1
    SET PC, msg_queue_reg_end

; Removes the (all) message queue(s) of the calling application
:msg_queue_rem
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C

    JSR proc_id     ; Gets the ID of the calling process

    SET B, message_queue_table

:msg_queue_rem_loop
    SET C, [B]
    SHR C, 8
    IFN C, A
        SET PC, msg_queue_rem_skip

    SET [B], 0x0000
    SET [1+B], 0x0000

:msg_queue_rem_skip
    ADD B, 2

    IFN B, message_queue_table_end
        SET PC, msg_queue_rem_loop

    SET C, POP
    SET B, POP
    SET A, POP
    SET PC, POP

; Sends a message to all message queues
; A -> Message source
; B -> Message content
:msg_broadcast
    SET PUSH, C
    SET PUSH, Y
    SET PUSH, Z

    SET C, [message_queue_table]

:msg_broadcast_loop
    SET Y, [C]
    IFN Y, 0
        JSR msg_send_to
    ADD C, 2
    IFN C, message_queue_table_end
        SET PC, msg_broadcast_loop

    SET Z, POP
    SET Y, POP
    SET C, POP
    SET PC, POP

; Sends a message to a specific process
; A -> Message source
; B -> Message content
; C -> Addr of the entry of the message queue
:msg_send_to
    SET PUSH, A       ; Save registers
    SET PUSH, B
    SET PUSH, I
    SET PUSH, J
    SET PUSH, C

    SET I, [C]        ; Get the pointers
    SET J, I

    AND I, 0x0002     ; Is the queue full?
    IFE I, 0x0002
        SET PC, msg_send_to_end

    SET I, J          ; Restore I

    SHR I, 1          ; "decompress" the pointers
    SHR J, 4
    AND I, 0x000E
    AND J, 0x000E

    SET C, [1+C]      ; address of the message queue
    ADD I, C          ; address of the new entry

    SET [I], A        ; Write message to the queue
    SET [1+I], B

    SUB I, C          ; Calculate the new pointer
    ADD I, 2
    AND I, 0x000E

    SET C, POP

    AND [C], 0xFF03   ; delete the pointers
    IFE I, J          ; queue full?
        BOR [C], 0x0002

    SHL J, 4          ; "compress" the pointers
    SHL I, 1
    BOR I, J

    BOR [C], I        ; write the pointers

:msg_send_to_end
    SET J, POP        ; Restore registers
    SET I, POP
    SET B, POP
    SET A, POP
    SET PC, POP

; Gets the next message for the current process
; A <- Source of the message
; B <- Content of the message
:msg_get_message
    SET PUSH, X
    SET PUSH, Z

    JSR proc_id
    JSR msg_find_proc_addr ; Finds the address of the process' message queue structure

    IFE A, 0          ; There is no message queue for this process
        SET PC, msg_get_message_end

    SET Z, A

    SET X, [Z]             ; SET X the flags
    SHR X, 4               ; Calculate the read ptr
    AND X, 0x000E
    ADD X, [1+Z]

    SET A, [X]             ; Reads the message
    SET B, [1+X]
    SET [X], 0x0000        ; Removes the message
    SET [1+X], 0x0000

    SUB X, [1+Z]           ; Calculate the new read pointer
    ADD X, 2
    AND X, 0x000E
    SHL X, 4

    AND [Z], 0xFF1D        ; Delete old read pointer and queue full flag
    BOR [Z], X             ; Save the new read pointer

:msg_get_message_end
    SET Z, POP
    SET X, POP
    SET PC, POP

; Finds the addr of the message queue of a given process in the message queue table
; A -> process ID
; A <- addr (or 0 if not exists)
:msg_find_proc_addr
    SET PUSH, B
    SET PUSH, C

    SET B, A
    SHL B, 8
    SET A, message_queue_table

:msg_find_proc_addr_loop
    SET C, [A]
    AND C, 0xFF00
    IFE C, B
        SET PC, msg_find_proc_addr_end
    ADD A, 2
    IFN A, message_queue_table_end
        SET PC, msg_find_proc_addr_loop

    SET A, 0            ; Nothing found

:msg_find_proc_addr_end
    SET C, POP
    SET B, POP
    SET PC, POP



; Copies a string from a source to a destination
; A -> source address
; B -> destination address:strcpy
:strcpy
    SET PUSH, A
    SET PUSH, B

:strcpy_loop
    IFE [A], 0
        SET PC, strcpy_end
    SET [B], [A]
    ADD A, 1
    ADD B, 1
    SET PC, strcpy_loop

:strcpy_end
    SET B, POP
    SET A, POP
	SET PC, POP

; Copies a string from a source to a destination with length limitation
; Takes:
; A: source
; B: destination
; C: length
:strncpy
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C

    ADD C, B
:strncpy_loop1
    IFE [A], 0
        SET PC, strncpy_loop2
    SET [B], [A]
    ADD A, 1
    ADD B, 1
    IFE B, C
        SET PC, strncpy_end
    SET PC, strncpy_loop1

:strncpy_loop2
    SET [B], 0
    ADD B, 1
    IFN B, C
        SET PC, strncpy_loop2

:strncpy_end
    SET C, POP
    SET B, POP
    SET A, POP
SET PC, POP

; Compares strings and stores the result in C and O
; A=B => C=0, O=0
; A>B => C>0, O=0
; A<B => C>0, O>0
; Takes:
; A: source #1
; B: source #2
:strcmp
    SET PUSH, A
    SET PUSH, B
    SET O, 0
    SET C, 0
:strcmp_loop
    IFE [A], 0
        SET PC, strcmp_end
    IFN [A], [B]
        SET PC, strcmp_end
    ADD A, 1
    ADD B, 1
    SET PC, strcmp_loop

:strcmp_end
    SET C, [A]
    SUB C, [B]
    SET B, POP
    SET A, POP
    SET PC, POP 

; Stores the length of a given string in B
; A: Address of the string buffer
:strlen
	SET PUSH, A

	SET B, 0
:strlen_loop
	IFE [A], 0
		SET PC, strlen_end
	ADD A, 1
	SET PC, strlen_loop
:strlen_end
	SET B, A
	SUB B, PEEK

	SET A, POP
	SET PC, POP

; Reads a line of chars from the keyboard
; A: String buffer address
; B: Length
; C: Keybuffer
:read_line
     SET PUSH, C
     SET PUSH, B
     SET PUSH, A

     JSR mem_clear ; Clear the buffer

     ADD B, A

:read_line_loop
	 JSR proc_suspend
     IFE [C], 0
         SET PC, read_line_skip
     IFE [C], 0xA
         SET PC, read_line_end
     IFE [C], 0x8
         SET PC, read_line_backspace
     IFE A, B
         SET PC, read_line_skip

     SET [A], [C]

; Put the character on-screen so the user can see what is being typed
; Maybe have this toggleable?
     SET PUSH, A
     SET PUSH, B
     SET B, [A]
     BOR B, 0x7400
     SET A, B
     SET B, [video_cur]
     SET [B], A
     ADD [video_cur], 1
     SET B, POP
     SET A, POP

     ADD A, 1

:read_line_skip
     SET PC, read_line_loop

:read_line_backspace
; Ensure we don't backspace past the beginning
     IFE A, PEEK
     SET PC, read_line_skip

     SET PUSH, A
     SET PUSH, B
     SUB [video_cur], 1
     SET B, [video_cur]
     SET [B], 0
     SET B, POP
     SET A, POP
     SUB A, 1
     SET PC, read_line_skip

;
:read_line_end
; Add the null terminator
     SET [A], 0
; Pop everything back out
     SET A, POP
     SET B, POP
     SET C, POP
     SET PC, POP

; Sleeps for some cycles
; TODO: Change this (or add a new func.) to wait for a specific number of CPU cycles
; A: number of process cycles to wait
:sleep
    IFE A, 0
		SET PC, POP
    SUB A, 1
    JSR proc_suspend
    SET PC, sleep

; Returns a randomized number in A
:rand
    MUL [entropy], 52265
    ADD [entropy], 135
    SET A, [entropy]
    SET PC, POP

; Takes a seed in A
:srand
	MUL A, 49763
	SHL A, 2
	XOR A, 1273
	SET [entropy], A
	SET PC, POP
	
; ########################################

; FILESYSTEM FUNCTIONS
	
; Return start of the filesystem
:filesystem_getfile_table
	SET A, files_table
	SET PC, POP
	
; Returns pointer to start of file entry in file table in C, returns 0 if file not found
; A: buffer containing file name
:filesystem_getfile
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A
	
	SET B, A
	
	JSR filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:filesystem_getfile_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, filesystem_getfile_end
	SUB X, 1
	
	ADD A, 2 ; Skip over the directory ID and flags
	JSR strcmp ; Check if the current filename (A) matches the original filename (B)
	IFE C, 0
		SET PC, filesystem_getfile_found
	ADD A, 18 ; Skip over the filename, start, and end
	
	SET PC, filesystem_getfile_loop
:filesystem_getfile_found
	SUB A, 2 ; Backs up the pointer to the start of the file entry
	SET C, A ; Sets C to the start of the entry

	;JSR newline ; DEBUG
	;SET A, text_start_ok ; DEBUG
	;JSR text_out ; DEBUG
:filesystem_getfile_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP

; Returns pointer to start of current directory name string in file table in C, if root returns 0
; takes nothing
:filesystem_current
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A
	
	IFE [present_working_directory], 0
		
	JSR filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:filesystem_current_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, filesystem_current_root
	SUB X, 1
	
	ADD A, 1 ;skip over directory ID
	SET B, [A] ; set B to flags
	AND B, 0x10 ; check to see if entry is a directory
	IFN B, 0x10
		SET PC, filesystem_current_fileskip
	ADD A, 17 ;skip name to directory start ID
	IFE [A], [present_working_directory] ; match present working directory to table entry
		SET PC, filesystem_current_found
	ADD A, 1 ; Skip over the end
	
	SET PC, filesystem_current_loop

:filesystem_current_fileskip
	SUB X, 1 ;reduce file count
	ADD A, 18 ;skip over name, start, end
	SET PC, filesystem_current_loop

:filesystem_current_root
	SET C, 0
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP

:filesystem_current_found
	SUB A, 16 ; Backs up the pointer to the start of the folder name
	SET C, A ; Sets C to the start of the entry

	;JSR newline ; DEBUG
	;SET A, text_start_ok ; DEBUG
	;JSR text_out ; DEBUG
:filesystem_current_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP
	
; ########################################

; Halts the CPU
:stop SET PC, stop

:data

; OS Variables
:os_version_main dat 0x0000
:os_version_sub dat 0x0005
:os_version_fix dat 0x0005

:video_mem dat 0x8000
:video_col dat 0x7000
:video_cur dat 0x8000
:video_clear dat 0x7020

:text_start dat "AtlasOS v0.5.5 starting... ", 0x00
:text_start_ok dat "OK", 0xA0, 0x00
:text_logo1 DAT "      ___   __   __", 0xA0
:text_logo2 DAT "     /   | / /_ / /____ ______", 0xA0
:text_logo3 DAT "    / /| |/ __// // __ `/ ___/", 0xA0
:text_logo4 DAT "   / ___ / /  / // /_/ (__  )", 0xA0
:text_logo5 DAT "  /_/  |_\\_/ /_/ \\__,_/____/", 0xA0
:text_logo6 DAT "         / __ \\/ ___/", 0xA0
:text_logo7 DAT "        / / / /\\__ \\", 0xA0
:text_logo8 DAT "       / /_/ /___/ /", 0xA0
:text_logo9 DAT "       \\____//____/", 0xA0, 0x00

:page_map
:page_map0 dat 0x0000
:page_map1 dat 0x0000
:page_map2 dat 0x0000
:page_map3 dat 0x0000

:page_table              ; 128 words
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:page_table_end

:message_queue_table     ; 32 words
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:message_queue_table_end

:proc_current dat 0x0001
:proc_buffer dat 0x0000
:proc_buffer_a dat 0x0000
:proc_buffer_b dat 0x0000
:proc_buffer_c dat 0x0000
:proc_buffer_x dat 0x0000
:proc_buffer_y dat 0x0000
:proc_buffer_z dat 0x0000
:proc_buffer_i dat 0x0000
:proc_buffer_j dat 0x0000
:proc_buffer_sp dat 0x0000
:proc_buffer_mem dat 0x0000
:proc_buffer_flags dat 0x0000
:proc_table
       dat 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_table10
       dat 0xFFFF, 0x0000, 0xFFFD ; OS-Proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 1st proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 2nd proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 3rd proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 4th proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; 5th proc
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 ; [...]
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
       dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_table_end

; Keyboard driver variables
:keyboard_buffers
dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:keyboard_buffers_end
:keyboard_buffers_flags
dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:keyboard_buffers_flags_end
:keyboard_buffers_exclusive dat 0x0000 ; Contains buffer mem loc that has exclusive access
:keyboard_oldvalue dat 0x0000

; Kernel watchdog variables
:kernel_watchdog_proc_list_buffer
	dat 0x0000, 0x0000
:kernel_watchdog_proc_list_buffer_end

; This is used to buffer the character set before a foreground application is loaded
; and to restore it after the app has closed
; This will allow foreground applications to alter the character set without impacting
; applications that will run after the foreground app has closed
:char_set
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:char_set_end
:screen_buffer_exclusive dat 0x0000

:entropy dat 0x0000

:api_start ; API starts at 0x1000
    SET PC, os_version		; Returns the version of AtlasOS
    SET PC, proc_id 		; Returns the ID of the current process
    SET PC, proc_suspend 	; Suspends the process and starts the next
    SET PC, proc_get_addr 	; Returns the address of the current processes memory
    SET PC, proc_get_flags 	; Returns the flags of the current process
    SET PC, proc_kill_me 	; Kills the current process
    SET PC, proc_kill 		; Kills a process
    SET PC, page_alloc 		; Allocates another 1024 words
    SET PC, page_free 		; Frees allocated memory
    SET PC, mem_clear 		; Clears memory
    SET PC, pusha 			; Pushes all registers to the stack
    SET PC, popa 			; Pops all registers from the stack
    SET PC, strcpy 			; Copies a string
    SET PC, strncpy 		; Copies a string with length limitation
    SET PC, text_out 		; Displays a text on the screen
    SET PC, newline 		; Linefeed
    SET PC, scroll 			; Scrolls the screen one line
    SET PC, clear 			; Clears the screen
    SET PC, char_put 		; Puts a char on the screen
    SET PC, read_line 		; Reads a line from the keyboard to a buffer
    SET PC, rand 			; Gets a random number
    SET PC, keyboard_register ; Registers a specific memory location as keyboard buffer
    SET PC, keyboard_unregister ; Unregisters a specific memory location
    SET PC, int2dec 		; Converts a value into the decimal representation
    SET PC, int2hex 		; Converts a value into the hexadecimal representation
	SET PC, atoi 			; Converts a textual, decimal number into the actual integer value
	SET PC, strlen 			; Returns the length of a null-terminated string
	SET PC, strcmp 			; Compares two null-terminated strings to see if they're equal
	SET PC, page_check		; Returns the amount of free memory
	SET PC, srand			; Initializes the random number generator
	SET PC, proc_load		; Loads a new process
	SET PC, proc_callback_list ; Dumps a list of running processes
	SET PC, keyboard_is_exclusive_active ; Set A to non-zero if there is an exclusive keyboard buffer active
	SET PC, filesystem_getfile ; Returns the start of the filesystem in A
	SET PC, filesystem_getfile_table ; Returns the start of the filesystem file table. May be deprecated later
	SET PC, filesystem_current ; Returns start address of present working directory name string in file table.
:api_end

; API Padding. This is temporary to buffer the kernel so that the API space doesn't overwrite program code
; TODO: Need to find a way to pad the kernel up to 0x1400 dynamically
; 2560 words
:api_padding
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "                                                                                                                                "
	dat "          "

:kernel_end
; ################################
; ################################
:apps



; BASH-like Process
:AtlasShell
	SET A, text_versionoutput
	JSR [AtlasShell_text_out]
:AtlasShell_start
	SET I, AtlasShell_loop_end ; Calculate the length of the back-jump
	SUB I, AtlasShell_loop

	; Register our buffer with the driver
	SET A, input_buffer
	JSR [AtlasShell_keyboard_register]

:AtlasShell_loop
	; First check if anything is taking exclusive keyboard access
	JSR [AtlasShell_keyboard_is_exclusive_active]
	IFN A, 0
		SET PC, AtlasShell_loop_wait

	; Display current directory
	JSR [AtlasShell_filesystem_current]
	IFE C, 0
	    SET PC, AtlasShell_prompt
	SET A, C
	JSR [AtlasShell_text_out]
 :AtlasShell_prompt
	; Display the prompt
	SET A, text_prompt
	JSR [AtlasShell_text_out]

	; Reset the basics
	SET [ack_command], 0 ; reset command recognized

	; Read a line from the keyboard
	SET A, input_text_buffer
	SET B, 32
	SET C, input_buffer
	JSR [AtlasShell_read_line]

	; Skip everything if we got an empty line
	SET A, input_text_buffer
	JSR [AtlasShell_strlen]
	IFE B, 0
		SET PC, AtlasShell_loop_wait

	; Parse out the primary command
	SET A, input_text_buffer
	SET B, 0
	JSR shell_getparameter

	; Check for the 'clear' command
	SET A, command_clear
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE C, 0
		JSR command_clearf

	; Check for the 'version' command
	SET a, command_version
	SET b, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE c, 0
	JSR command_versionf

	; Check for the 'load' command
	SET a, command_load
	SET b, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE c, 0
	JSR command_loadf

	; Check for the 'kill' command
	SET a, command_kill
	SET b, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE c, 0
	JSR command_killf

	; Check for the 'list' command
	SET a, command_list
	SET b, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE c, 0
	JSR command_listf
	
	; Check for the 'ls' command
	SET A, command_ls
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE C, 0
		JSR command_lsf
		
	; Check for the 'cd' command
	SET A, command_cd
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE C, 0
		JSR command_cdf
		
	; Check if we're trying to run a file
	IFN [ack_command], 1
		JSR command_runfile

	; If we don't have an acknowledged command, display the generic response
	ifn [ack_command], 1
	JSR command_unknownf
:AtlasShell_loop_wait
	; Pause then loop back to start of process
	JSR [AtlasShell_proc_suspend]
	SUB PC, I
:AtlasShell_loop_end

; ==BEGIN COMMAND FUNCTIONS==
; Command function when we got an unknown command
:command_unknownf
	JSR [AtlasShell_newline]
	SET a, text_unrecognized
	JSR [AtlasShell_text_out]
	SET pc, pop

; Command function to display version info
:command_versionf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Clear the param buffer
	SET A, command_parameter_buffer
	SET B, 16
	JSR [AtlasShell_mem_clear]
	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; Check if our param was blank
	SET A, command_parameter_buffer
	JSR [AtlasShell_strlen]
	IFE B, 0
		SET PC, command_versionf_shell

	; Check if our param was 'os' to give OS version
	SET A, command_version_os
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE C, 0
		SET PC, command_versionf_os
:command_versionf_shell
	JSR [AtlasShell_newline]
	SET A, text_versionoutput
	JSR [AtlasShell_text_out]
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
:command_versionf_os
	JSR [AtlasShell_newline]
	JSR command_os_version_display
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Command function to clear the screen
:command_clearf
	SET [ack_command], 1 ; acknowledge recognized command
	JSR [AtlasShell_clear]
	SET pc, pop

; Command function to load a new process
:command_loadf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR command_clear_parameter_buffer

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; check if blank > load help
	SET A, command_parameter_buffer
	JSR [AtlasShell_strlen]
	IFE B, 0
		SET PC, command_loadf_help

	;check if list > list applications in table
	SET A, command_parameter_buffer
	SET B, command_list
	JSR [AtlasShell_strcmp]
	IfE C, 0
		SET PC, command_loadf_list

	SET A, application_table

:command_loadf_loop
	IFE A, application_table_end ; if index is at the end of the table, we have an unknown app
		SET PC, command_loadf_unknown
	IFG A, application_table_end ; if index is at the end of the table, we have an unknown app
		SET PC, command_loadf_unknown
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp] ; compare table string to parameter
	IFE C, 0
		SET PC, command_loadf_loop_end ; if equal move to end

	; Get the length of the app name and move our pointer forward past that
	JSR [AtlasShell_strlen]
	ADD A, B
	; Skip past the null terminator, the start address, and the end address
	ADD A, 3
	SET PC, command_loadf_loop

:command_loadf_loop_end
	SET PUSH, A
	JSR [AtlasShell_newline]
	SET A, command_parameter_buffer
	JSR [AtlasShell_strlen]
	SET A, POP
	ADD A, B
	ADD A, 1

	; Load the start & end addresses and start the process
	SET B, A
	ADD B, 1
	SET A, [A]
	SET B, [B]
	SUB B, A

	JSR [AtlasShell_proc_load]

        IFE A, 0
            SET PC, command_loadf_unknown

	SET [last_proc], A
	SET PC, command_loadf_end

:command_loadf_help
	JSR [AtlasShell_newline]
	SET A, command_load_help
	JSR [AtlasShell_text_out]
	SET PC, command_loadf_end

:command_loadf_list
	JSR command_clear_parameter_buffer ;clear parameter buffer so list command doesn't run afterwards
	JSR [AtlasShell_newline]
	SET A, application_table
:command_loadf_list_loop
	IFE A, application_table_end ; if index is at the end of the table, finish listing apps
		SET PC, command_loadf_end
	IFG A, application_table_end ; if index is past end of the table, finish listing apps
		SET PC, command_loadf_end
	JSR [AtlasShell_text_out] ;print out app name
	JSR [AtlasShell_newline]
	; Get the length of the app name and move our pointer forward past that
	JSR [AtlasShell_strlen]
	ADD A, B
	; Skip past the null terminator, the start address, and the end address
	ADD A, 3
	SET PC, command_loadf_list_loop ; loopback

:command_loadf_unknown
	JSR [AtlasShell_newline]
	SET A, command_load_unknown
	JSR [AtlasShell_text_out]

:command_loadf_end
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [AtlasShell_proc_suspend]
	SET PC, POP

; Command function to kill a running process
:command_killf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR command_clear_parameter_buffer

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	; Check if our param was blank
	SET A, command_parameter_buffer
	JSR [AtlasShell_strlen]
	IFE B, 0
		SET PC, command_killf_help

	; Check if our param was 'last' to kill the last process
	SET A, command_kill_last
	SET B, command_parameter_buffer
	JSR [AtlasShell_strcmp]
	IFE C, 0
		SET PC, command_killf_last

	; Convert the param to an integer
	SET A, command_parameter_buffer
	JSR [AtlasShell_atoi]	; A is source, C is result

	; Selfkill?
	SET PUSH, A
	JSR [AtlasShell_proc_id]
	IFE A, C      ; Wants to kill me?
		SET PC, AtlasShell_die
	SET A, POP

	; Trying to kill OS?
	IFE C, 1
		SET PC, command_killf_forbidden

	; Kill the corresponding process
	JSR [AtlasShell_newline]
	SET A, C
	JSR [AtlasShell_proc_kill]
	SET PC, command_killf_end
:command_killf_forbidden
	JSR [AtlasShell_newline]
	SET A, command_kill_forbidden
	JSR [AtlasShell_text_out]
	SET PC, command_killf_end
:command_killf_last
	JSR [AtlasShell_newline]
	SET A, [last_proc]
	JSR [AtlasShell_proc_kill]
	SET PC, command_killf_end
:command_killf_help
	JSR [AtlasShell_newline]
	SET A, command_kill_help
	JSR [AtlasShell_text_out]
:command_killf_end
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [AtlasShell_proc_suspend]
	SET PC, POP

; Command function to list process IDs
:command_listf
	SET [ack_command], 1
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Clear the process ID buffer first
	SET A, proc_list_buffer
:command_listf_clear_proc_list
	IFE A, proc_list_buffer_end
		SET PC, command_listf_end
	SET [A], 0
	ADD A, 1
	SET PC, command_listf_clear_proc_list

:command_listf_end
	; Get the process ID list
	SET C, proc_list_buffer
	SET A, command_listf_helper
	JSR [AtlasShell_proc_callback_list]

	JSR [AtlasShell_newline]
	SET A, command_list_info
	JSR [AtlasShell_text_out]
	SET A, 0 ; OS process
	JSR command_listf_display_procID
	SET A, 1 ; Shell process
	JSR command_listf_display_procID
	SET A, 2
	JSR command_listf_display_procID
	SET A, 3
	JSR command_listf_display_procID
	SET A, 4
	JSR command_listf_display_procID
	SET A, 5
	JSR command_listf_display_procID

	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
:command_listf_helper
	SET [C], A
	ADD C, 1
	SET PC, POP
:command_listf_display_procID
	JSR command_clear_number_buffer

	; Now display the list on-screen
	SET B, proc_list_buffer
	ADD B, A
	SET A, [B]
	; Don't display if it's 0
	IFE A, 0
		SET PC, POP
	; Convert to text and display
	SET B, command_number_buffer
	JSR [AtlasShell_int2dec]
	SET A, command_number_buffer
	JSR [AtlasShell_text_out]
	JSR [AtlasShell_newline]

	SET PC, POP
	
; Command to list all files in current directory
:command_lsf
	SET [ack_command], 1
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET PUSH, X
	SET PUSH, Y
	JSR [AtlasShell_newline]
	JSR [AtlasShell_filesystem_getfile_table]
	SET X, [A]
	SET Y, 0
	ADD A, 1
:command_lsf_loop
	IFE Y, X
		SET PC, command_lsf_end
	ADD Y, 1
	SET B, command_ls_row

	SET PUSH, A
	SET C, [A] ; Ignore the directory value for now, will be finished later
	SET A, [present_working_directory]
	IFN C, A
		SET PC, command_lsf_skip_file
	SET A, POP
	
	ADD A, 1 ; Move on to flags
	
	; Store if this file can be read
	SET C, [A]
	AND C, 0x0001
	IFE C, 1
		SET [B], 0x52 ; 'R'
	ADD B, 1
	
	; Store if this file can be written to
	SET C, [A]
	AND C, 0x0002
	IFE C, 2
		SET [B], 0x57 ; 'W'
	ADD B, 1
	
	; Store if this file is executable
	SET C, [A]
	AND C, 0x0008
	IFE C, 8
		SET [B], 0x45 ; 'E'
	ADD B, 1
	
	; Check if the file is hidden
	SET C, [A]
	AND C, 0x0004
	IFE C, 4
		SET [B], 0x48 ; 'H'

		; Store if this is a directory
	SET C, [A]
	AND C, 0x0010
	IFE C, 16
		SET [B], 0x44 ; 'D'
	ADD B, 1

	; Add separator
	SET [B], 0x7C ; '|'
	ADD B, 1
	ADD A, 1
	
	; Store the file name
	JSR [AtlasShell_strcpy]
	ADD B, 16
	ADD A, 16
	
	; Add separator
	SET [B], 0x7C ; '|'
	ADD B, 1
	;ADD A, 1
	
	IFE C, 16
		SET PC, command_lsf_skip_filesize
	
	; Display file size
	SET C, [A] ; Get the file start
	ADD A, 1
	SET PUSH, A
	SET A, [A]
	SUB A, C
	JSR [AtlasShell_int2dec]
	SET A, POP
:command_lsf_skip_filesize	
	IFE C, 16
		ADD A, 1
	; Output the file info
	SET C, A
	SET A, command_ls_row
	JSR [AtlasShell_text_out]
	SET A, C
	SET PC, command_lsf_skip_file_end
:command_lsf_skip_file
	SET A, POP
	ADD A, 19
:command_lsf_skip_file_end
	; Clear out the row buffer
	SET C, command_ls_row
	ADD C, 32
	SET B, command_ls_row
:command_lsf_clearrow
	SET [B], 0x20
	ADD B, 1
	IFN B, C
		SET PC, command_lsf_clearrow
	
	; Move on to the next entry
	ADD A, 1
	SET PC, command_lsf_loop
:command_lsf_end
	;JSR [AtlasShell_proc_suspend]
	SET Y, POP
	SET X, POP
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
	
:command_runfile
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	JSR [AtlasShell_newline]

	SET A, command_parameter_buffer
	JSR [AtlasShell_filesystem_getfile]
	IFE C, 0
		SET PC, command_runfile_end
		
	SET A, [C] ; Skip over the directory ID, will finish later
	IFN A, [present_working_directory]
		SET PC, command_runfile_end
	
	ADD C, 1
	SET A, [C] ; Get the file flags
	AND A, 0x0008 ; Check if the file is executable
	IFE A, 0
		SET PC, command_runfile_notexe
		
	ADD C, 1
	
	ADD C, 16
	SET A, [C]
	ADD C, 1
	SET B, [C]
	SUB B, A
	JSR [AtlasShell_proc_load]
	IFN A, 0
		SET [ack_command], 1
	SET PC, command_runfile_end
:command_runfile_notexe
	SET A, command_runfile_notexe_text
	JSR [AtlasShell_text_out]
	SET [ack_command], 1
:command_runfile_end	
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
	
:command_cdf
	SET [ack_command], 1 ; acknowledge recognized command
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

	; Capture the param
	SET A, input_text_buffer
	SET B, 1
	JSR shell_getparameter

	JSR [AtlasShell_newline]

	;check if 'cd'
	SET A, command_parameter_buffer
	SET B, command_cd
	JSR [AtlasShell_strcmp]
	IFE C, 0
		SET PC, command_cdf_help

	; check if blank > load help
	SET A, command_parameter_buffer
	JSR [AtlasShell_strlen]
	IFE B, 0
		SET PC, command_cdf_help

	;check if '..'
	SET A, command_parameter_buffer
	SET B, command_cd_back
	JSR [AtlasShell_strcmp]
	IFE C, 0
		SET PC, command_cdf_back

	;check if '/'
	SET A, command_parameter_buffer
	SET B, command_cd_root
	JSR [AtlasShell_strcmp]
	IFE C, 0
		SET PC, command_cdf_root

	JSR [AtlasShell_filesystem_getfile]
	IFN C, 0
		SET PC, command_cdf_cd
	SET PC, command_cdf_unknown

:command_cdf_help
	SET A, command_cd_help
	JSR [AtlasShell_text_out]
	SET PC, command_cdf_end

:command_cdf_back
	SET A, directory_stack
	SET B, 15
	ADD B, A
:command_cdf_back_traverse_directorystack
	IFE A, B
		SET PC, command_cdf_back_end
	IFE [A], 0
		SET PC, command_cdf_back_end
	ADD A, 1
	SET PC, command_cdf_back_traverse_directorystack
:command_cdf_back_end
	SUB A, 2
	SET [present_working_directory], [A]
	SET [A], 0
	SET PC, command_cdf_end

:command_cdf_root
	SET A, 0x0000
	SET [present_working_directory], A
	SET B, 16 ; Current max directory depth, hardcoded for now
	SET A, directory_stack
:command_cdf_root_clear_directorystack
	IFE B, 0
		SET PC, command_cdf_end
	SUB B, 1
	SET [A], 0
	ADD A, 1
	SET PC, command_cdf_root_clear_directorystack

:command_cdf_unknown
	SET A, command_parameter_buffer
	JSR [AtlasShell_text_out]
	SET A, command_cd_unknown
	JSR [AtlasShell_text_out]
	SET PC, command_cdf_end

:command_cdf_cd
	IFN [C], [present_working_directory] ; Check if we're trying to access a directory not in our current directory
		SET PC, command_cdf_unknown
	ADD C, 1 ; Move past to the flags
	SET A, [C]
	AND A, 0x0010 ; Check the flags to see if this file is a directory
	IFN A, 16
		SET PC, command_cdf_unknown
	ADD C, 1 ; Move to the name
	
	ADD C, 16 ; Move past the name
	
	SET B, directory_stack
	SET A, 16
	ADD A, B
:command_cdf_cd_addtodirectorystack
	IFE B, A
		SET PC, command_cdf_end ; Directory stack is full, cannot change directory
	IFE [B], 0
		SET PC, command_cdf_cd_addtodirectorystack_end
	ADD B, 1
	SET PC, command_cdf_cd_addtodirectorystack
:command_cdf_cd_addtodirectorystack_end
	SET A, [C] ; Store the directory ID
	SET [B], A
	SET [present_working_directory], A

:command_cdf_end
	JSR command_clear_parameter_buffer
	SET C, POP
	SET B, POP
	SET A, POP
	JSR [AtlasShell_proc_suspend]
	SET PC, POP

:AtlasShell_die
	SET A, input_buffer
	JSR [AtlasShell_keyboard_unregister]
	JSR [AtlasShell_newline]
	JSR [AtlasShell_proc_kill_me]

; ==BEGIN HELPER FUNCTIONS==
; Displays OS version using API call to get version numbers
; TODO: Make the output more user-friendly
:command_os_version_display
	JSR command_clear_number_buffer
	SET A, 0
	SET B, 0
	SET C, 0
	; A - main version, B - sub version, C - fix version
	JSR [AtlasShell_os_version]
	SET PUSH, C
	SET PUSH, B
	MUL A, 10000
	SET B, command_number_buffer
	JSR [AtlasShell_int2dec]
	IFE A, 0
		SET [B], 0x0030
	SET A, command_number_buffer
	SET B, POP
	SET A, B
	MUL A, 100
	SET B, command_number_buffer
	JSR [AtlasShell_int2dec]
	SET A, command_number_buffer
	SET C, POP
	SET A, C
	SET B, command_number_buffer
	JSR [AtlasShell_int2dec]
	SET A, command_number_buffer
	ADD A, 1
	SET [A], [command_version_separator]
	ADD A, 2
	SET [A], [command_version_separator]
	SET A, command_number_buffer
	JSR [AtlasShell_text_out]
	JSR [AtlasShell_newline]
	SET PC, POP
; Clears the parameter buffer
:command_clear_parameter_buffer
	SET PUSH, A
	SET PUSH, B
	SET A, command_parameter_buffer
	SET B, 32
	JSR [AtlasShell_mem_clear]
	SET B, POP
	SET A, POP
	SET PC, POP
; Clears the number buffer
:command_clear_number_buffer
	; Empty the temp buffer
	SET PUSH, A
	SET A, command_number_buffer
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	ADD A, 1
	SET [A], 32
	SET A, POP
	SET PC, POP

; Takes a command input and parses out a parameter
; A: Address of source text buffer
; B: Which param we want to parse out (starts at 0)
:shell_getparameter
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	; C will keep track of which param we're looking at
	SET C, 0
:shell_getparameter_loop
	IFE C, B
	SET PC, shell_getparameter_save
	IFE [A], 32
	ADD C, 1
	ADD A, 1
	IFE [A], 0
	SET PC, shell_getparameter_end
	SET PC, shell_getparameter_loop
:shell_getparameter_save
	SET B, command_parameter_buffer
:shell_getparameter_save_loop
	SET [B], 0
	IFE [A], 32
	SET PC, shell_getparameter_end
	IFE [A], 0
	SET PC, shell_getparameter_end
	IFE [A], 10
	SET PC, shell_getparameter_end
	SET [B], [A]
	ADD A, 1
	ADD B, 1
	SET PC, shell_getparameter_save_loop
:shell_getparameter_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; Data
:input_text_buffer dat "                                ", 0x00
:input_buffer dat 0x0000
:ack_command dat 0x00
:command_clear dat "clear", 0
:command_version dat "version", 0
:command_version_os dat "os", 0
:command_version_separator dat ".", 0
:command_load dat "load", 0
:command_load_help dat "Syntax: load [appID]", 0xA0, 0x00
:command_load_unknown dat "Failed to load application", 0xA0, 0x00
:command_kill dat "kill", 0
:command_kill_forbidden dat "Cannot kill process: Forbidden", 0xA0, 0x00
:command_kill_help dat "Syntax: kill [last|procID]", 0xA0, 0x00
:command_kill_last dat "last", 0
:command_list dat "list", 0
:command_list_info dat "Process list:", 0xA0, 0x00
:command_parameter_buffer dat "                                ", 0x00
:command_number_buffer dat "     ", 0x00
:command_ls dat "ls", 0
:command_ls_row dat "                                ", 0x00
:command_cd dat "cd", 0
:command_cd_back dat "..", 0
:command_cd_root dat "/", 0
:command_cd_help dat "Syntax : cd [directory|..|/]", 0xA0, 0x00
:command_cd_unknown dat " doesnt exist", 0xA0, 0
:command_runfile_notexe_text dat "File is not executable", 0xA0, 0x00

; API Jump table
:AtlasShell_os_version dat 0x1000 ; 0th index in API * 2 words long = 0x00, os_version
:AtlasShell_proc_id dat 0x1002 ; 1st index in API * 2 words long = 0x02, proc_id
:AtlasShell_proc_suspend dat 0x1004 ; 2nd index in API * 2 words long = 0x04, proc_suspend
:AtlasShell_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
:AtlasShell_proc_kill dat 0x100C ; 6th inded in API * 2 words long = 0x0C, proc_kill
:AtlasShell_mem_clear dat 0x1012 ; 9th index in API * 2 words long = 0x12, mem_clear
:AtlasShell_strcpy dat 0x1018 ; 12th index in API * 2 words long = 0x18, strcpy
:AtlasShell_text_out dat 0x101C ; 14th index in API * 2 words long = 0x1C, text_out
:AtlasShell_newline dat 0x101E ; 15th index in API * 2 words long = 0x1E, newline
:AtlasShell_clear dat 0x1022 ; 17th index in API * 2 words long = 0x22, char_put
:AtlasShell_read_line dat 0x1026 ; 19th index in API * 2 words long = 0x26, read_line
:AtlasShell_keyboard_register dat 0x102A ; 21st index in API * 2 words long = 0x2A, keyboard_register
:AtlasShell_keyboard_unregister dat 0x102C ; 22nd index in API * 2 words long = 0x2C, keyboard_unregister
:AtlasShell_int2dec dat 0x102E ; 23rd index in API * 2 words long = 0x2E, int2dec
:AtlasShell_atoi dat 0x1032 ; 25th index in API * 2 words long = 0x32, atoi
:AtlasShell_strlen dat 0x1034 ; 26th index in API * 2 words long = 0x34, strlen
:AtlasShell_strcmp dat 0x1036 ; 27th index in API * 2 words long = 0x36, strcmp
:AtlasShell_proc_load dat 0x103C ; 30th index in API * 2 words long = 0x3C, proc_load
:AtlasShell_proc_callback_list dat 0x103E ; 31st index in API * 2 words long = 0x3E, proc_callback_list
:AtlasShell_keyboard_is_exclusive_active dat 0x1040 ; 32nd index in API * 2 words long = 0x40, keyboard_is_exclusive_active
:AtlasShell_filesystem_getfile dat 0x1042 ; 33rd index in API * words long = 0x42, filesystem_getfile
:AtlasShell_filesystem_getfile_table dat 0x1044 ; 34th index in API * 2 words long = 0x44, filesystem_getfile_table
:AtlasShell_filesystem_current dat 0x1046 ; 35th index in API * 2 words long = 0x44, filesyste_current

:proc_list_buffer
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:proc_list_buffer_end
:last_proc dat 0x0000

:text_unrecognized dat "Unrecognized command", 0xA0, 0x00
:text_versionoutput dat "Atlas-Shell v0.3.3", 0xA0, 0x00
:text_prompt dat "$> ", 0x00

:present_working_directory dat 0x0000
:directory_stack
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
	dat 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
:directory_stack_end

; Note: This application table will be changed / go away once we have a filesystem
;application_table_format
;dat "name_of_app", 0, app_location, app_location_end
:application_table
:app1 dat "ball", 0, app02, app02_end
:app2 dat "AtlasText", 0, AtlasText, AtlasText_end
:app3 dat "AtlasShell", 0, AtlasShell, AtlasShell_end
:application_table_end

:AtlasShell_end


; AtlasText - A simple, dummy text editor
:AtlasText
	JSR [AtlasText_clear]

	SET I, AtlasText_loop_end ; Calculate the length of the back-jump
	SUB I, AtlasText_loop

	; Register our buffer with the driver
	SET A, AtlasText_input_buffer
	; And ask for exclusive keyboard access
	SET B, 1
	JSR [AtlasText_keyboard_register]
:AtlasText_loop
	; If we hit ESC kill the editor
	IFE [AtlasText_input_buffer], 0x001B
		SET PC, AtlasText_die

	; Just print the text to the screen
	SET A, AtlasText_input_buffer
	JSR [AtlasText_text_out]

	JSR [AtlasText_proc_suspend]
	SUB PC, I
:AtlasText_loop_end
:AtlasText_die
	SET A, AtlasText_input_buffer
	JSR [AtlasText_keyboard_unregister]
	JSR [AtlasText_clear]
	JSR [AtlasText_proc_kill_me]
:AtlasText_data
	:AtlasText_input_buffer dat 0x0000, 0x0000
	; API Jump table
	:AtlasText_text_out dat 0x101C ; 14th index in API * 2 words long = 0x1C, text_out
	:AtlasText_proc_suspend dat 0x1004 ; 2nd index in API * 2 words long = 0x04, proc_suspend
	:AtlasText_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
	:AtlasText_keyboard_register dat 0x102A ; 21st index in API * 2 words long = 0x2A, keyboard_register
	:AtlasText_keyboard_unregister dat 0x102C ; 22nd index in API * 2 words long = 0x2C, keyboard_unregister
	:AtlasText_clear dat 0x1022 ; 17th index in API * 2 words long = 0x22, char_put
:AtlasText_end

:app02
	SET X, 1
	SET Y, 1

	SET I, app02_loop_end
	SUB I, app02_loop

	SET J, 200

	; Register our buffer with the driver
	SET A, app02_input_buffer
	;SET B, 1
	JSR [app02_keyboard_register]

	SET A, 0
	SET B, 0
	SET C, 0

:app02_loop
	; Restore the old character
	SET C, Z
        IFE C, 0
            ADD PC, 4
        IFN C, 0x744F
	    JSR [app02_char_put]

	; If we reached the end of the iterations, quit
	SUB J, 1
	IFE J, 0
		JSR app02_die

	; Update the coordinates of the ball
	ADD A, X
	ADD B, Y

	IFE A, 31
	SET X, 0xFFFF

	IFE B, 11
	SET Y, 0xFFFF

	IFE A, 0
	SET X, 1

	IFE B, 0
	SET Y, 1

	; Save the character before we write so we can restore later
	SET PUSH, B
	MUL B, 32
	ADD B, A
	ADD B, 0x8000
	SET Z, [B]
	SET B, POP

	SET [app02_wait_counter], 8
:app02_wait_loop
	SET PUSH, [app02_wait_counter]
	JSR app02_update_ball
	SET [app02_wait_counter], POP
	SUB [app02_wait_counter], 1
	IFN [app02_wait_counter], 0
		SET PC, app02_wait_loop

	JSR [app02_proc_suspend]
	SUB PC, I
:app02_loop_end
:app02_update_ball
	SET C, 0x7400
	IFN [app02_input_buffer], [app02_old_input_buffer]
		IFN [app02_input_buffer], 0
			SET [app02_ball_char], [app02_input_buffer]
	BOR C, [app02_ball_char]
	JSR [app02_char_put]

	IFN [app02_input_buffer], 0
		SET [app02_old_input_buffer], [app02_input_buffer]
	JSR [app02_proc_suspend]
	SET PC, POP
:app02_die
	SET A, app02_input_buffer
	JSR [app02_keyboard_unregister]
	JSR [app02_proc_kill_me]
	SET PC, POP
:app02_data
	:app02_input_buffer dat 0x0000
	:app02_old_input_buffer dat 0x0000
	:app02_ball_char dat 0x0000
	:app02_wait_counter dat 0x0000
	; API Jump table	
	:app02_proc_suspend dat 0x1004 ; 2nd index in API * 2 words long = 0x04, proc_suspend
	:app02_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
	:app02_keyboard_register dat 0x102A ; 21st index in API * 2 words long = 0x2A, keyboard_register
	:app02_keyboard_unregister dat 0x102C ; 22nd index in API * 2 words long = 0x2C, keyboard_unregister
	:app02_char_put dat 0x1024 ; 18th index in API * 2 words long = 0x24, char_put
:app02_end

:hello ; beginning of application
	SET A, hello_world
	JSR [hello_text_out]
	JSR [hello_proc_suspend]
	JSR [hello_proc_kill_me]

	:hello_world dat "Hello World", 0xA0, 0x00
	; API Jump table
	:hello_proc_suspend dat 0x1004 ; 2nd index in API * 2 words long = 0x04, proc_suspend
	:hello_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
	:hello_text_out dat 0x101C ; 14th index in API * 2 words long = 0x1C, text_out
:hello_end

:free
	JSR [free_page_check]
	SET X, 0xFFFF
	SUB X, A
	SET A, X
	SET B, free_buffer
	JSR [free_int2dec]
	SET B, free_buffer2
	DIV A, 1024
	SHL A, 1
	JSR [free_int2dec]
	SET A, free_buffer
	JSR [free_text_out]
	SET A, free_buffer
	JSR [free_proc_kill_me]
	
	:free_buffer  dat "      words free ("
	:free_buffer2 dat "      KB)", 0xA0, 0x00
	; API Jump table
	:free_text_out dat 0x101C ; 14th index in API * 2 words long = 0x1C, text_out
	:free_int2dec dat 0x102E ; 23rd index in API * 2 words long = 0x2E, int2dec
	:free_proc_kill_me dat 0x100A ; 5th index in API * 2 words long = 0x0A, proc_kill_me
	:free_page_check dat 0x1038 ; 28th index in API * 2 words long = 0x38, page_check
:free_end



:apps_end

:files

; Primary file table
; Flags: Bit 0 - read, Bit 1 - write, Bit 2 - hidden, Bit 3 - executable, Bit 4 - directory
; Each entry must be 20 words long
; directory ID, flags, name, null terminator, padding, start, end
; For directory entries, the 'start' contains the ID and the 'end' is unused
:files_table
	dat 0x0007 ; Number of files in table
	dat 0x0000, 0x0011, "TextFiles", 0, "      ", 0x0001, 0x0000
	dat 0x0000, 0x0011, "Programs", 0, "       ", 0x0002, 0x0000
	dat 0x0002, 0x0011, "System", 0, "         ", 0x0003, 0x0000
	dat 0x0001, 0x0003, "file01", 0, "         ", file01, file01_end
	dat 0x0002, 0x0009, "hello_world", 0, "    ", file02, file02_end
	dat 0x0003, 0x0009, "free_mem", 0, "       ", file03, file03_end
	dat 0x0001, 0x0005, "file04", 0, "         ", file04, file04_end
:files_table_end

; Basic flat text file
:file01
	dat "This is some text from a file   "
	dat "Blah blah some more content     "
	dat "Termination", 0x00
:file01_end

; HelloWorld
; Description: Displays 
:file02 ; AtlasOS ABI-compliant executable file
	dat 0x4714 ; Magic number indicating an AtlasOS ABI-comliant binary
	dat 0x0001 ; Revision 1 of the ABI
	dat 0x000A ; Length of header (5 base + 5 for ART)
	dat 0x0018 ; Length of the code and data
	dat 0x000B ; Flags 00000000 00001011
	dat 0x0004 ; ART length
	dat 0x0001, 0x0003, 0x0005, 0x0007 ; ART entries
	; Code
	dat 0x7C01, 0x0008, 0x7810, 0x0017, 0x7810, 0x0015, 0x7810, 0x0016
	; Data
	dat 0x0048, 0x0065, 0x006c, 0x006c, 0x006f, 0x0020, 0x0057, 0x006f, 0x0072, 0x006c, 0x0064, 0x00a0, 0x0000, 0x1004, 0x100A, 0x101C
:file02_end

; Free
; Description: Displays the amount of free memory in RAM
:file03 ; AtlasOS ABI-compliant executable file
	dat 0x4714 ; Magic number indicating an AtlasOS ABI-comliant binary
	dat 0x0001 ; Revision 1 of the ABI
	dat 0x000F ; Length of header (5 base + 10 for ART)
	dat 0x003A ; Length of the code and data
	dat 0x000B ; Flags 00000000 00001011
	dat 0x0009 ; ART length
	dat 0x0001, 0x0007, 0x0009, 0x000B, 0x0010, 0x0012, 0x0014, 0x0016, 0x0018 ; ART entries
	; Code
	dat 0x7810, 0x0039, 0x7c31, 0xffff, 0x0033, 0x0c01, 0x7c11, 0x0019, 0x7810, 0x0037, 0x7c11, 0x002b, 0x7c05, 0x0400, 0x8407, 0x7810
	dat 0x0037, 0x7c01, 0x0019, 0x7810, 0x0036, 0x7c01, 0x0019, 0x7810, 0x0038
	; Data
	dat 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0077, 0x006f, 0x0072, 0x0064, 0x0073, 0x0020, 0x0066, 0x0072, 0x0065, 0x0065, 0x0020, 0x0028
	dat 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x004b, 0x0042, 0x0029, 0x00a0, 0x0000
	dat 0x101c, 0x102e, 0x100a, 0x1038
:file03_end

:file04
	dat "I am hidden, muahaha!", 0x00
:file04_end



:files_end
