; ########VIRTUAL FILESYSTEM FUNCTIONS########
	
; Return start of the filesystem
:virtual_filesystem_getfile_table
	SET A, files_table
	SET PC, POP
	
; Returns pointer to start of file entry in file table in C, returns 0 if file not found
; A: buffer containing file name
:virtual_filesystem_getfile
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A
	
	SET B, A
	
	JSR virtual_filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:virtual_filesystem_getfile_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, virtual_filesystem_getfile_end
	SUB X, 1
	
	ADD A, 2 ; Skip over the directory ID and flags
	JSR strcmp ; Check if the current filename (A) matches the original filename (B)
	IFE C, 0
		SET PC, virtual_filesystem_getfile_found
	ADD A, 18 ; Skip over the filename, start, and end
	
	SET PC, virtual_filesystem_getfile_loop
:virtual_filesystem_getfile_found
	SUB A, 2 ; Backs up the pointer to the start of the file entry
	SET C, A ; Sets C to the start of the entry

:virtual_filesystem_getfile_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP
	
; Returns pointer to start of file entry in file table in C, returns 0 if file not found
; A: Program start or directory ID
:virtual_filesystem_getfile_bystart
	SET PUSH, X
	SET PUSH, B
	SET PUSH, A
	
	SET B, A
	
	JSR virtual_filesystem_getfile_table
	SET X, [A] ; Get the number of files in the table
	ADD A, 1 ; Jump down to the start of the table
:virtual_filesystem_getfile_bystart_loop
	SET C, 0 ; Reset our return
	IFE X, 0 ; Check if we've gone through all of the files
		SET PC, virtual_filesystem_getfile_bystart_end
	SUB X, 1
	
	ADD A, 18 ; Skip over the directory ID, flags, and filename
	IFE B, [A]
		SET PC, virtual_filesystem_getfile_bystart_found
	
	ADD A, 2 ; Skip over end and jump to next entry
	
	SET PC, virtual_filesystem_getfile_bystart_loop
:virtual_filesystem_getfile_bystart_found
	SUB A, 18 ; Backs up the pointer to the start of the file entry
	SET C, A ; Sets C to the start of the entry

:virtual_filesystem_getfile_bystart_end
	SET A, POP
	SET B, POP
	SET X, POP
	SET PC, POP
	
; ######END VIRTUAL FILESYSTEM FUNCTIONS######

; ############PHYSICAL FILESYSTEM#############

; *** Hardware Functions ***
; Returns the sector size in words
:filesystem_getsectorsize
SET A, [floppy_words_per_sector]
SET PC, POP

; Returns the total number of sectors
:filesystem_getsectorcount
SET A, [floppy_sectors]
SET PC, POP

; Returns the total disk size in words
:filesystem_getdisksize
SET A, [floppy_sectors]
MUL A, [floppy_words_per_sector]
SET PC, POP

; *** Software Functions ***
; Returns the total FAT size in sectors
:filesystem_getFATsize

; Returns the total number of free sectors on the disk
:filesystem_getfreespace


; reads a number of floppy sectors from the floppy from a starting sector in the floppy to the floppy paging space
; A --> start sector
; B --> number of sectors
:filesystem_read_disk_sectors
IFG A, 1439
	SET PC, filesystem_error
IFG B, 6
	SET PC, filesystem_error

SET PUSH, C ; push c, x, y for code safety
SET PUSH, X
SET PUSH, Y

SET PUSH, B ; store A and B
SET PUSH, A

SET A, 0x002 ; query device flags
HWI [floppy_address]
SET Y, B ; store flags

AND A, 0xFFFE ; set device to blocking mode
SET B, A
SET A, 0x0003
HWI [floppy_address]

SET A, 0x0010 ; read sector interrupt
SET B, PEEK ; start at sector given by A
SET C, PICK 1 ; read a number of sectors given by B
SET X, [floppy_paging_address]
HWI [floppy_address]

IFG A, 0
	SET PC, filesystem_error

SET B, Y ;retrieve flags
SET A, 0x3 ; reset flags
HWI [floppy_address]

SET A, POP
SET B, POP
SET Y, POP
SET X, POP
SET C, POP
SET PC, POP

; Writes a number of floppy sectors from the floppy paging space to a starting sector on the floppy.
; A --> start sector
; B --> number of sectors
:filesystem_write_disk_sectors
IFG A, 1439
	SET PC, filesystem_error
IFG B, 6
	SET PC, filesystem_error

SET PUSH, C ; push c, x, y for code safety
SET PUSH, X
SET PUSH, Y

SET PUSH, B ; store A and B
SET PUSH, A

SET A, 0x002 ; query device flags
HWI [floppy_address]
SET Y, B ; store flags

AND A, 0xFFFE ; set device to blocking mode
SET B, A
SET A, 0x0003
HWI [floppy_address]

SET A, 0x0011 ; write sector interrupt
SET B, POP ; start at a sector given by a
SET C, POP ; write a number of 512 word sectors
SET X, [floppy_paging_address]
HWI [floppy_address]

SET B, 0
IFG A, 0
	SET PC, filesystem_error

SET B, Y ;retrieve flags
SET A, 0x3 ; reset flags
HWI [floppy_address]

SET Y, POP
SET X, POP
SET C, POP
SET PC, POP

:filesystem_error
SUB PC, 1
; ##########END PHYSICAL FILESYSTEM###########

