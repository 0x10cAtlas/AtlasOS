; ##############################################################

; Returns the version of AtlasOS
; Takes: ---
; Returns:
; A: main version
; B: subversion
; C: fixversion
:os_version
      SET A, [os_version_main]
      SET B, [os_version_sub]
	  SET C, [os_version_fix]
	  SET PC, POP

; Returns the ID of the current process
; Takes: ---
; Returns:
; A: process ID
:proc_id
      SET A, [proc_current]
      SET PC, POP

; Returns the start address of the current process
; Takes: ---
; Returns:
; A: start address
:proc_get_addr
      JSR proc_id

:proc_get_addr_of
      JSR proc_get_info

      ADD A, 10
      SET A, [A]
      SET PC, POP

; Returns the flags of the current process
; Takes: ---
; Returns:
; A: flags
:proc_get_flags
      JSR proc_id

:proc_get_flags_of
      JSR proc_get_info_of

      ADD A, 3
      SET A, [A]
      SET PC, POP

; Returns the address of the process info structure
; Takes: ---
; Returns:
; A: address
:proc_get_info
      JSR proc_id

:proc_get_info_of
      MUL A, 5
      ADD A, proc_table
	  SUB A, 5
      SET PC, POP

; Sets the flags of the current process
; Takes:
; A: flags
; Returns: ---
:proc_set_flags
      SET PUSH, A
      JSR proc_get_info
      ADD A, 11
      IFN A, 11
          SET [A], PEEK
      SET A, POP
      SET PC, POP

; Sets the flags of a process
; Takes:
; A: process ID
; B: flags
; Returns: ---
:proc_set_flags_of
      SET PUSH, A
      JSR proc_get_info_of
      ADD A, 11
      IFN A, 11
          SET [A], B
      SET A, POP
      SET PC, POP

; Sets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_set_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      BOR A, 0x0001
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Resets the active flag of the process
; Takes:
; A: process ID
; Returns: ---
:proc_reset_flag_active_of
      SET PUSH, B
      SET PUSH, A

      JSR proc_get_flags_of
      AND A, 0xFFFE
      SET B, A
      SET A, POP
      JSR proc_set_flags_of

      SET B, POP
      SET PC, POP

; Toggles the active flag of the process
; Takes:
; A: process ID
; Returns:
; A: 1 - active, 0 - inactive
:proc_flag_is_active_of
      JSR proc_get_flags_of
      AND A, 0x0001
      SET PC, POP

; Generates a list of all process IDs and hands it over to a callback-function
; Takes:
; A: address of the callback-function (Takes: A: process ID, Returns: ---)
; Returns: ---
:proc_callback_list
      SET PUSH, B
      SET PUSH, A

      SET B, proc_table

:proc_callback_list_loop
      SET A, [B]
      IFN A, 0
          JSR PEEK
      ADD B, 5
      IFN B, proc_table_end
          SET PC, proc_callback_list_loop

      SET A, POP
      SET B, POP
      SET PC, POP

:proc_suspend
INT 0x1002
SET PC, POP


:proc_suspend_interrupt
ADD SP, 3
ifl [processes], 2
rfi a
ife [proc_realtime_id], [proc_current]
rfi a
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J
SET PUSH, EX

SET [int_msg], A


SET A, [proc_current]
MUL A, 5
SUB A, 5
ADD A, proc_table
ADD A, 1
SET [A], SP


add a, 4
:proc_kill_me_hook

:proc_suspend_loop
	IFE A, proc_table_end
		SET A, proc_table
	SET X, [A]
	IFN X, 0x0000
		SET PC, proc_suspend_invoke
	ADD A, 5
	SET PC, proc_suspend_loop

:proc_suspend_invoke

	SET [proc_current], [A]
	ADD A, 1
	SET SP, [A]
	set EX, POP
	set J, POP
	set I, POP
	set Z, POP
	set Y, POP
	set X, POP
	set C, POP
	set B, POP

	RFI A ; Jump into the Program


; Loads a new process into memory
; A: Begin of the BLOB
; B: Length of the BLOB
:proc_load
	IAQ 1
	SET PUSH, B
	SET PUSH, C
	SET PUSH, X
	SET PUSH, Y
	SET PUSH, Z
	SET PUSH, I
	SET PUSH, J

	SET C, 0 ; Clear this out because C might contain flag info if we load an ABI exe

	SET Z, [A]
	IFN [A], 0x4714  ; Check for magic number
		SET PC, proc_load_start
:proc_load_handle_exec
	ADD A, 1
	;SET C, [A] ; Do nothing with the revision # in this interim build
	ADD A, 1
	SET I, [A] ; Save the length of the header
	ADD A, 1
	SET J, [A] ; Save the length of the code+data
	ADD A, 1
	SET C, [A] ; Save the flags data
	SUB A, 4 ; And now move the pointer back to the start

:proc_load_start
	SET X, proc_table

:proc_load_loop
	IFE [X], 0x0000
		SET PC, proc_load_to

	ADD X, 5
	IFN X, proc_table_end
		SET PC, proc_load_loop

:proc_load_error
	SET A, 0
	SET PC, proc_load_end

; Load the process and fill the details in the proc_table.
; X -> addr of the empty proc_table record for this process
; A <- proc id
:proc_load_to
	; Calculate the ProcID by finding the proc_table record number (OS is 1).
	SET [X], X
	SUB [X], proc_table
	DIV [X], 5
	ADD [X], 1

	; X = ProcInfo Addr

	; Backup our flags
	SET PUSH, C

	; Finally load the Process - A is the source mem addr, B is length.
	SET C, B
	SET PUSH, A

	; If we're loading from a built-in app, we only need to allocate a page for the stack
	IFN Z, 0x4714
		SET B, A
	IFN Z, 0x4714
		SET PC, proc_load_stack_alloc

	; Pretend the routine has been called by this not-yet-loaded process, so we can allocate memory.
	SET PUSH, [proc_current]
	SET [proc_current], [X]

	SET B, C
	ADD B, 128 ; Give 128 words for stack space
	DIV B, 1024 ; Figure up the number of blocks we need (-1)
	ADD B, 1 ; Add one to our total to account for the rounding down in the above statement
	SET Y, B ; Store the number of pages so we can calculate the SP start
	SET A, B ; Set A to the number of pages to alloc to pass into page_alloc_big
	JSR page_alloc_big ; Allocate the pages, A now contains the starting address

	SET [proc_current], POP

	; Copy the program to the newly allocated memory.
	SET B, A ; Save the address of the new page
	SET A, PEEK ; Get back our original source address
	IFE Z, 0x4714
		ADD A, I ; If we are an ABI exe offset the copy destination by the size of the header
	IFE Z, 0x4714
		SET C, J ; If we are an ABI exe set the size to just the code length
	JSR mem_copy

	SET A, POP

	; Get the flags back.
	SET C, POP
	
	; Check if we have any flags to deal with
	IFN C, 0
		JSR proc_handle_flags
		
	; Calculate the stack address
	MUL Y, 1024 ; Get the end of the pages
	SUB Y, 1 ; Move back 1
	ADD Y, B ; Offset by the memory start

:proc_load_stack_alloc_end

	SET A, [X] ; A return the ProcID
	; Fill the proc_table entry for this process.

	; Set the SP to the last byte of the allocated memory page(s)
	ADD X, 1 ; SP
	SET [X], Y

	; Store the memory address of the process.
	ADD X, 1
	SET [X], B

	; Store flags
	ADD X, 1 ; Flags
	BOR C, 0x0001 ; OR in the active flag. This will overwrite the ART flag but we don't care
	SET [X], C

	SET [Y], B ; "Push" the "return" address on the process stack - this is the beginning of the process program.
	SUB X, 2 ; back to SP
	SUB [X], 9
	SET PUSH, A ; clear new proccess stack area so we start with each register being 0
	SET A, Y
	SUB A, 10
	SET B, 9
	JSR mem_clear
	SET A, POP


:proc_load_end
	; add to number of processes
	ADD [processes], 1

	SET J, POP
	SET I, POP
	SET Z, POP
	SET Y, POP
	SET X, POP
	SET C, POP
	SET B, POP
	IAQ 0
	INT 0x1002
	SET PC, POP

:proc_load_stack_alloc

	; Pretend the routine has been called by this not-yet-loaded process, so we can allocate memory.
	SET PUSH, [proc_current]
	SET [proc_current], [X]
	JSR page_alloc
	SET [proc_current], POP

	SET Y, A ; Save the address of the new page
	SET A, PEEK ; Get back our original source address
	ADD Y, 512
	SUB Y, 1

	SET A, POP

	; Get the flags back.
	SET C, POP

	; Check if we have any flags to deal with
	IFN C, 0
		JSR proc_handle_flags

	SET PC, proc_load_stack_alloc_end

:proc_handle_flags
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	
	; If bit 1 is true then backup the character set data
	SET PUSH, A
	SET A, 0 ; Param for manage_charset to save charset data
	AND C, 0x0002
	IFE C, 1
		JSR manage_charset
	SET A, POP
		
	SET C, PEEK
	AND C, 0x0001 ; Check if the app has an ART
	IFE C, 1
		JSR proc_exec_process_relocation
:proc_handle_flags_end	
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
	
; Handle the ART table for an application
; A -> Start of the ABI header (i.e. file start)
; B -> Copy of binary that we are modifying
:proc_exec_process_relocation
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	ADD A, 5
	SET C, [A] ; Get the number of entries in the relocaton table
:proc_exec_process_relocation_loop
	IFE C, 0
		SET PC, proc_exec_process_relocation_end
	SET PUSH, B
	SET PUSH, X
	SET X, B ; Store the program start location
	ADD A, 1 ; Increment to next entry in ART
	ADD B, [A] ; Add the ART offset to our pointer
	ADD [B], X ; Add the program start location to the program code
	SUB C, 1 ; Decrement our ART counter
	SET X, POP
	SET B, POP
	SET PC, proc_exec_process_relocation_loop
:proc_exec_process_relocation_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
	

; Kill self
:proc_kill_me
	JSR proc_id ; Save process ID
	SET X, A
	IFE [proc_realtime_id], A
	JSR proc_realtime
	JSR proc_get_info_of ; Save process info address
	SET Y, A
	ADD A, 2 ; Save memory page
	SET Z, [A]

	ADD A, 1 ; Move to the flags word
	SET A, [A] ; And retrieve the process flags
	AND A, 0x0002 ; Check if this was a foreground app
	IFE A, 1 ; Restore the character set. Since A is already 1 (restore charset) no need for extra ops here
		JSR manage_charset

	SET A, Y ; Delete the process info entry
	SET B, 4
	JSR mem_clear

	SET A, X
	JSR page_free_of
	SUB [processes], 1
	SET A, Y ; Restore the pointer to the info entry
	SET PC, proc_kill_me_hook

:proc_kill
      SET PUSH, B
      SET PUSH, Y
      SET PUSH, Z
      SET PUSH, A

      JSR proc_get_info_of ; Save process info address
      SET Y, A
      ADD A, 2 ; Save memory page
      SET Z, [A]

      SET A, Y ; Delete the process info entry
      SET B, 4
      JSR mem_clear

      SET A, POP ; Free the process memory page
      JSR page_free_of ; ! It will not be cleared !

	  SUB [processes], 1

      SET Z, POP
      SET Y, POP
      SET B, POP
      SET PC, POP

	  
:proc_realtime
	SET PUSH, A
	IFN [proc_realtime_id], 0
		SET PC, proc_realtime_off 
	JSR proc_id
	SET [proc_realtime_id], A
	SET A, POP
	SET PC, POP
	
:proc_realtime_off
	SET [proc_realtime_id], 0
	SET A, POP
	SET PC, POP
	
; ##############################################################

; Threading
; using the underlying process architecture, threads are created much in the same way as processes, except that when a process is killed any accociated threads are killed as well.
; threads are also designed to run through once before returning to the owning process. In theory a thread could own other threads. 
; Designed to allow effecient code reuse, ie a thread is created to manage a device by copying generic code. The owning process can then copy data into the thread memeory area to initilise it. Threads will have to prefaced with a relocation tabel to facilitate this. 
; Atlas is limited to 16 threads/proccesses including the kernel.  

; A -> thread code location
; B -> thread code length
; C -> boolean if 1 thread code is copied into new memory location. 
; A <- proc_id of thread
; B <- memory location of thread.
:create_thread
	IAQ 1
	SET PUSH, B
	SET PUSH, C
	SET PUSH, X
	SET PUSH, Y
	SET PUSH, Z
	SET PUSH, I
	SET PUSH, J
	
	
	SET X, proc_table

:create_thread_loop1
	IFE [X], 0x0000
		SET PC, create_thread_start

	ADD X, 5
	IFN X, proc_table_end
		SET PC, create_thread_loop1

:create_thread_error
	SET A, 0
	SET PC, create_thread_end
	
:create_thread_start
	SET [X], X
	SUB [X], proc_table
	DIV [X], 5
	ADD [X], 1

	; X = ProcInfo Addr
	
	IFN C, 1
		create_thread_stack_alloc
		
	SET C, B
	SET PUSH, A
	
	ADD B, 128
	DIV B, 1024
	ADD B, 1
	SET Y, B
	SET A, B, 
	


; Must be called inside a process
; A -> proc_id of thread.
; removes a thread from the process list. 
:kill_thread

; Must be called inside a process
; A -> proc_id of thread.
; sets up the process manager to switch to the thread.
:call_thread

; Must be called inside a thread
; Sets up the process manager to switch to the owning process. 
:return_thread
