:kernel_interrupt_handler
	SET PUSH, EX ; Safety measure in case we trigger between lines that use EX

	SUB A, 1 ; Go from HW+1 to HW
	
	; Run the keyboard driver no matter what the interrupt is
	; Maybe change this later but this is fast
	JSR driver_keyboard

	IFE A, [keyboard_address]
		JSR kernel_interrupt_handler_keyboard
	IFE A, [clock_address]
		JSR kernel_interrupt_handler_clock
	IFE A, [floppy_address]
		JSR kernel_interrupt_handler_floppy
		
	; ... All other handlers go here
	
	; These handler(s) must be the last one in the list
	; because it exits the kernel_interrupt_handler
	IFE A, [clock_address]
		IFN [preemptive_enabled], 0
			SET PC, kernel_interrupt_handler_manual
	IFE A, 0xFEDB
		SET PC, kernel_interrupt_handler_manual
		
	SET EX, POP
	RFI 0
	
:kernel_interrupt_handler_manual
	SET PUSH, C
	SET PUSH, B
	SET PUSH, A

	SET A, 2
	SET B, 0
	SET C, 0x6000
	JSR kernel_interrupt_debug_clock_ticker

	SET A, POP
	SET B, POP
	SET C, POP

	SET PC, proc_suspend_interrupt

:kernel_interrupt_handler_keyboard
	SET PC, POP
	
:kernel_interrupt_handler_clock
	SET PUSH, C
	SET PUSH, B
	SET PUSH, A

	SET A, 0
	SET B, 0
	SET C, 0x5000
	JSR kernel_interrupt_debug_clock_ticker
	
	SET A, POP
	SET B, POP
	SET C, POP

	SET PC, POP

:kernel_interrupt_handler_floppy
	JSR driver_floppy_handle_interrupt
	SET PC, POP
	
; ##################################################
	
; A -> X coordinate
; B -> Y coordinate
; C -> Color
:kernel_interrupt_debug_clock_ticker
	SET PUSH, C
	SET PUSH, B
	SET PUSH, A
	JSR rand
	AND A, 0x007F ; Keep it in range: 0 - 127
	BOR A, C ; Give some color
	SET C, A ; Save the character info
	SET A, POP
	SET B, POP
	JSR char_put
	SET C, POP
	
	SET PC, POP
	