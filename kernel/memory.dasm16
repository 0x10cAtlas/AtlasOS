; mem_clear
; A: From Addr
; B: Length
:mem_clear
	SET PUSH, A
	SET PUSH, B

	ADD B, A

:mem_clear_loop
	SET [A], 0
	ADD A, 1
	IFN A, B
	   SET PC, mem_clear_loop

	SET B, POP
	SET A, POP
	SET PC, POP

; mem_copy
; Copies data from one location to another
; Takes 4 cycles per loop for a copy speed of 25,000 words per second
; A -> source
; B -> dest
; C -> length
:mem_copy
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET PUSH, I
	SET PUSH, J

	; Calulate the last address
	ADD C, A

	; Some prep work so we can use STI
	SET I, B
	SET J, A

:mem_copy_loop
	STI [I], [J]
	IFN J, C
		SET PC, mem_copy_loop

	SET J, POP
	SET I, POP
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP
	 
; Reserve memory for the current process
; A: Mem address of the page
:page_reserve
	SET PUSH, B
	SET PUSH, A
	
	
	JSR proc_id
	SET B, A
	SET A, POP
	JSR page_reserve_for
	
	SET B, POP
	SET PC, POP
	
; Reserve memory for the process given by B
; A: Mem address of the page
; B: Process ID number
:page_reserve_for
	SET PUSH, B
	SET PUSH, A
	DIV A, 512
	SET [A+page_table], B
	JSR page_set_map
	
	SET A, POP
	SET B, POP
	SET PC, POP

; Free page number given by A
:page_remove
	SET [A+page_table], 0
	JSR page_unset_map
	SET PC, POP

; Reserve memory for the current process
; A: Mem address of the page
; B: number of pages
:page_reserve_big
	SET PUSH, B
	SET PUSH, A
	
:page_reserve_big_loop
	JSR page_reserve
	IFE B, 0
	SET PC, page_reserve_big_end
	ADD A, 512
	SUB B, 1
	SET PC, page_reserve_big_loop
:page_reserve_big_end
	SET A, POP
	SET B, POP

; Finds the first free page of memory by inspecting the bits of the page_map.
; A <- first free page number.
:page_find_free
	SET PUSH, I
	SET PUSH, J
	SET PUSH, B

	SET I, page_map
	SET J, 0
:page_find_free_loop
	; 0xFFFF means given 16kB is fully occupied.

	IFN [I], 0xFFFF
		SET PC, page_find_free_found
	STI A, A
	IFE J, 8
		SET PC, page_find_free_none
	IFN J, 8
		SET PC, page_find_free_loop

:page_find_free_none
	; Nothing found, exiting! (later: Swap)
	SET A, 0

:page_find_free_end	
	SET B, POP
	SET J, POP
	SET I, POP
	SET PC, POP

; Find free page within this 16kB block by looking for a bit set to 0.
:page_find_free_found
	SET PUSH, [I]
	 ; J is the id of the page_map word - each word covers 16 pages.
	MUL J, 16
	 ; A will hold the final number.
	SET A, J

:page_find_free_found_loop
	SHR PEEK, 1
	IFN EX, 0x0000
	   SET PC, page_find_free_skip

	ADD SP, 1
	SET PC, page_find_free_end

:page_find_free_skip
	ADD A, 1
	SET PC, page_find_free_found_loop


; Allocates a page for the current application
; A <- Address of the allocated memory page.
:page_alloc
	SET PUSH, B

	JSR page_find_free
	IFE A, 0
	   SET PC, page_alloc_error

	; Calculate the real mem address of the allocated page.
	MUL A, 512
	 
	JSR page_reserve


:page_alloc_end
	SET B, POP
	SET PC, POP

:page_alloc_error
	SET A, 0
	SET PC, page_alloc_end
	

	
; Allocates multiple pages for the application to be used if the application exceeds one page length
; A -> number of pages to allocate
; A <- address of first page.
:page_alloc_big
	SET PUSH, C
	SET PUSH, B

	SET B, A ; Store the number of pages
	SUB B, 1

	JSR page_alloc
	SET PUSH, A
	IFE A, 0
		SET PC, page_alloc_big_error
	IFE B, 0
		SET PC, page_alloc_big_end
:page_alloc_big_loop
	JSR page_alloc
	IFE A, 0
		SET PC, page_alloc_big_error
	SUB B, 1
	IFN B, 0
		SET PC, page_alloc_big_loop
:page_alloc_big_end
	SET A, POP
	SET B, POP
	SET C, POP
	SET PC, POP
:page_alloc_big_error
	SET A, POP
	SET A, 0
	SET PUSH, A
	SET PC, page_alloc_big_end

; Frees the given page for the current application
; A: memory
:page_free
	SET PUSH, A
	DIV A, 512
	JSR page_remove
	SET A, POP
	SET PC, POP


; Deallocate all pages belonging to the process
; A -> proc_id (or proc info structure)
:page_free_of
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET B, A
	SET A, 0
	SET C, page_table_end
	SUB C, page_table
	
:page_free_of_loop
	IFE [A+page_table], B
		JSR page_remove
	IFE A, C
		SET PC, page_free_of_end
	ADD A, 1
	SET PC, page_free_of_loop
	


:page_free_of_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP

; A: page num
:page_set_map
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET C, A
	SET B, 0x0001

	DIV A, 16
	MOD C, 16

	SHL B, C
	BOR [page_map+A], B

:page_set_map_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP



; A: page num
:page_unset_map
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C
	SET C, A

	SET B, 0x0001

	DIV A, 16
	MOD C, 16


	SHL B, C
	XOR B, 0xFFFF
	AND [page_map+A], B

:page_unset_map_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP


; Returns the amount of reserved memory
:page_check
	SET PUSH, B

	SET B, page_table
	SET A, 0

:page_check_loop
	IFN [B], 0
	   ADD A, 512
	ADD B, 1
	IFN B, page_table_end
	   SET PC, page_check_loop

	SET B, POP
	SET PC, POP


:page_check_of
	SET PUSH, B
	SET PUSH, C
	SET PUSH, A

	SET B, page_table
	SET A, 0

:page_check_of_loop
	SET C, [B]
	IFE C, PEEK
	   ADD A, 512
	ADD B, 1
	IFN B, page_table_end
	   SET PC, page_check_of_loop

	ADD SP, 1
	SET C, POP
	SET B, POP
	SET PC, POP